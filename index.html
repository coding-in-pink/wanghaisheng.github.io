
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>海生的世界</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Edwin">
    

    
    <meta name="description" content="loserdeworld.com">
<meta property="og:type" content="website">
<meta property="og:title" content="海生的世界">
<meta property="og:url" content="http://wanghaisheng.github.io/index.html">
<meta property="og:site_name" content="海生的世界">
<meta property="og:description" content="loserdeworld.com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="海生的世界">
<meta name="twitter:description" content="loserdeworld.com">
<meta name="twitter:creator" content="@edwin_uestc">
<link rel="publisher" href="111190881341800840000">

    
    <link rel="alternative" href="/atom.xml" title="海生的世界" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="海生的世界" title="海生的世界"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="海生的世界">海生的世界</a></h1>
				<h2 class="blog-motto">正在打怪升级中～～～</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:wanghaisheng.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/27/bottled-water-real-time-integration-of-postgresql-and-kafka/" title="Bottled Water-PostgreSQL与 Kafka的实时数据整合" itemprop="url">Bottled Water-PostgreSQL与 Kafka的实时数据整合</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-04-27T08:34:12.000Z" itemprop="datePublished"> 发表于 Apr 27 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="Bottled_Water:_PostgreSQL与_Kafka_的实时数据整合">Bottled Water: PostgreSQL与 Kafka  的实时数据整合</h2><p> 英文版： <a href="http://blog.confluent.io/2015/04/23/bottled-water-real-time-integration-of-postgresql-and-kafka/" target="_blank" rel="external">Bottled Water: Real-time integration of PostgreSQL and Kafka</a><br> 中文版：<br> <a href="http://wanghaisheng.github.io/2015/04/27/bottled-water-real-time-integration-of-postgresql-and-kafka" target="_blank" rel="external">Bottled Water: PostgreSQL与 Kafka  的实时数据整合</a></p>
<p>写数据库相对容易，读数据库则异常困难。当然，如果你只是查询数据库，拿到一部分值，也还行。但如果你想要将整个数据库中的数据复制到其他系统中去，比如使用Elasticsearch来<br>做索引，做快速的pre-fill缓存，或是将数据导入到一个数据仓库供统计分析，或是迁移到其他类型的数据库中。</p>
<p>如果数据不会发生变更，实现起来也很简单。只需要一份数据库的快照(通过备份dump整个数据库)，复制然后载入到其他系统即可。但问题是如果数据库是持续变更的，<br>在你载入数据的时候快照中的数据已经不是最新的，即使你采用每日一次快照的方式，在下游系统中你只能拿到滞后一天的数据，对于数据量大的数据库而言，快照和大数据量的加载（bulk load<br>本身成本就很高。</p>
<p>从一个数据库复制数据到另外的系统中有哪些解决方案呢？</p>
<ul>
<li>1、第一种是系统实现双写“dual writes”。每当系统进行数据库的写操作的时候，同时更新/校验缓存条目，对搜索引擎的数据重新索引，将数据发送到用于统计分析的系统等等<br><img src="../../../../images/slide-37-4-3.png" alt=""></li>
</ul>
<p>然而之前我就<a href="http://martin.kleppmann.com/2014/10/28/staying-agile-at-span.html" target="_blank" rel="external">谈到</a>,双写的方法其实是有很多问题的，主要是Race Condition(也叫做资源竞争)和可靠性的方面。如果稍有差异的数据写到2个不同的数据库中，数据库的内容会慢慢的相差甚远，随着时间的推移会变得越来越不一致。<br>要想从这样的渐进式的数据损坏中恢复是很困难的。</p>
<ul>
<li>2、CDC 变更数据捕获<br>如果是从数据库的快照中重新构建缓存或索引，这样做的好处在于从新的数据库备份中重新构建时会消除任何的不一致性。但对于大型数据库而言，每天要处理整个数据库备份速度太慢，效率太低，怎么样才能提速呢？</li>
</ul>
<p>典型的，不同的快照之间数据库只有一小部分会发生变化。如果你只是处理自上次快照之后数据库中发生的那些变更？这样只用处理一小部分数据，也可以频繁的进行比对。比如说每分钟比对一次，每秒比对一次？1秒100次呢？</p>
<p>当比对频率达到极限的时候，数据库的变更就变成了stream流。每次写数据库时，也就是流中的一条消息。如果你把这些消息严格按照原来数据提交时的顺序应用到数据库上，你就可以得到一份和数据库一模一样的副本，这其中的原理也就是<a href="http://blog.confluent.io/2015/03/04/turning-the-database-inside-out-with-apache-samza/" target="_blank" rel="external">数据库复制的原理</a></p>
<p>复制的方法来保持数据同步比双写的方法要好一些。首先，你只需要写一个数据库。然后从数据库中拿到2个东西：<br>1、某时刻下满足一致性的快照<br>2、自那个时刻之后的实时的变更流</p>
<p>你可以将快照导入到其他系统(比如搜索索引或缓存)，然后持续的应用这些实时的变更。如果管道是警告调优的，那么你的延迟可能低于1秒，下游系统也可以保持尽可能最新。由于变更流本身包括了写的顺序，<a href="https://martin.kleppmann.com/2015/04/24/logs-for-data-infrastructure-at-craft.html" target="_blank" rel="external">资源竞争就不再是问题</a></p>
<p>这种方法常常称为<a href="http://en.wikipedia.org/wiki/Change_data_capture" target="_blank" rel="external">变更数据捕获</a>,目前现有的一些工具都不是很好用。但在一些公司里，CDC已经成为了系统构建的关键模块，比如Linkedin有<a href="http://www.socc2012.org/s18-das.pdf" target="_blank" rel="external">Databus</a>。Facebook有<a href="https://code.facebook.com/posts/188966771280871/wormhole-pub-sub-system-moving-data-through-space-and-time/" target="_blank" rel="external">Wormhole</a></p>
<p>CDC 变更数据捕获能够让你释放你已有数据中的价值。你可以将数据“喂”给一个<a href="http://blog.confluent.io/2015/02/25/stream-data-platform-1/" target="_blank" rel="external">中心式的数据流</a><br>这样就可以实时与来自其他数据库的数据或时间流整合起来。这种方式使得新的数据分析或新的数据格式试验更加容易，允许你以一种最小化的风险渐进式地从<br>一个系统迁移到另一个系统，也比 data corruption更加健壮，如果出了任何问题，你都可以很快的利用快照和流恢复数据库。</p>
<p><img src="../../../../images/slide-42b-4-3.png" alt=""></p>
<h2 id="获取实时的变更流">获取实时的变更流</h2><p>获取数据库的一致性快照是一个通用的特性，因为你需要利用它进行备份。但获取实时的变更流是传统数据库一直忽略的一个功能。<br> Oracle <a href="http://www.oracle.com/us/products/middleware/data-integration/goldengate/overview/index.html" target="_blank" rel="external">GoldenGate</a>, the <a href="https://dev.mysql.com/doc/refman/5.7/en/binary-log.html" target="_blank" rel="external">MySQL binlog</a>, the <a href="http://www.manuel-schoebel.com/blog/meteorjs-and-mongodb-replica-set-for-oplog-tailing" target="_blank" rel="external">MongoDB oplog</a> or the <a href="http://guide.couchdb.org/draft/notifications.html" target="_blank" rel="external">CouchDB changes feed</a> 都是类似的功能，但要想用好都不是那么容易。近来一些数据库如 <a href="http://rethinkdb.com/blog/realtime-web/" target="_blank" rel="external">RethinkDB</a> or <a href="https://www.firebase.com/docs/web/guide/retrieving-data.html" target="_blank" rel="external">Firebase</a> 正在朝着实时变更流的方向努力。</p>
<p>这里我们主要看看<strong>PostgreSQL</strong>. 它是一个很古老的数据库，但是很好用，很稳定、性能不错，也拥有绝大多数的<a href="https://vimeo.com/61044807" target="_blank" rel="external">功能</a>。</p>
<p>以前你如果想从Postgres中拿到变更流你必须使用触发器。这样是可以实现，但fiddly，需要变更schema，且性能不大好。但去年12月份发布的Postgresql 9.4引入了一种叫<a href="http://www.postgresql.org/docs/9.4/static/logicaldecoding.html" target="_blank" rel="external"> logical decoding逻辑编码</a>的新特性，</p>
<p>有了logical decoding之后,Postgres的变更数据捕获突然变得更加吸引人。因此，当发布了这一功能之后，我立即利用这一特性开始为Postgres构建一个变更捕获工具<a href="http://confluent.io/" target="_blank" rel="external">Confluent</a>赞助了我这个项目，目前我们发布了一个alpha的开源版本 <a href="https://github.com/confluentinc/bottledwater-pg" target="_blank" rel="external">Bottled Water</a>.</p>
<p><img src="../../../../images/slide-44-4-3.png" alt="Bottled Water: Data streams freshly bottled at source"></p>
<h2 id="Bottled_Water简介"><strong>Bottled Water简介</strong></h2><p>Logical decoding利用了数据库的write-ahead log (WAL),能够让我们访问行级别的变更事件：每次一张表的某一行出现插入、更新删除操作。这类事件是利用事务来分组的，是以它们提交到数据库的顺序出现的。流中并不会记录Aborted/rolled-back事务。因此，如果你以同样的顺序应用这些变更事件，就能得到一个与数据库的事务保持一致的副本。</p>
<p>Postgres logical decoding 的设计是很精巧的：利用变更流能够构建出一个一致性的快照来。你可以使用快照来做整个数据库某个时间点的备份，无需锁库即可完成备份，然后通过变更流获取所有自快照之后发生的写操作。</p>
<p>Bottled Water 利用这些特性来复制数据库中的所有数据，将数据编码成 <a href="http://avro.apache.org/" target="_blank" rel="external">Avro format</a>格式.然后把编码后的数据发送给<a href="http://kafka.apache.org/" target="_blank" rel="external">Kafka</a> — 数据库中的每张表作为一个Kafka topic,数据库中的每一行作为Kafka中的一条消息。</p>
<p>一旦数据导入到Kafka里面,你可以按你所需来编写Kafka consumer that does whatever you need:发送数据给Elasticsearch, 生成一份缓存，在 <a href="http://samza.apache.org/" target="_blank" rel="external">Samza</a> job中进行处理, 利用<a href="http://confluent.io/docs/current/camus/docs/intro.html" target="_blank" rel="external">Camus</a>将数据导入到HDFS with … 等等</p>
<h2 id="为什么选择_Kafka?"><strong>为什么选择 Kafka?</strong></h2><p>Kafka 是一个消息系统，以大量事件的传输闻名，诸如web服务器日志，用户点击事件。在Kafka里,此类事件通常保留一段时间然后就丢弃掉。 Kafka是否真的适合数据库的变更事件。我们不希望丢掉任何的数据库数据。</p>
<p>事实上， Kafka 是不二之选—  最关键的是Kafka’s <a href="http://kafka.apache.org/documentation.html#compaction" target="_blank" rel="external">log compaction feature</a>, 简直就是为了这个目的量身定做的. 如果你启动log compaction,就不会存在按照时间对数据进行丢弃。相反，每个消息都有一个key，Kafka会无限保留某个<br>key对应的最新的消息。某个key值之前的消息最终通过garbage-collected来采集。这与key-value键值数据库中使用新的值覆盖旧的值是一样的道理。</p>
<p>Bottled Water确定了 (or <a href="http://michael.otacoo.com/postgresql-2/postgres-9-4-feature-highlight-replica-identity-logical-replication/" target="_blank" rel="external">replica identity</a>)Postgres中每张表的主键，并将其用作发送给Kafka消息的主键。消息值取决于事件的类型：</p>
<ul>
<li>对于插入和更新操作，消息值包含了每行所有字段的值，编码成Avro格式</li>
<li>对于删除操作，消息值为null。这样 Kafka 就会在 log compaction时移除消息,这样就释放了磁盘空间</li>
</ul>
<p>通过log compaction,你不再需要一个系统来存储整个数据库的快照，用另一个系统来处理实时的消息-二者可以在同一个系统中并存。<br>Bottled Water把最开始的快照按照数据库中每行作为一个消息发送给Kafka，主键作为消息的key，发送给所有Kafka brokers.当处理完了快照，插入的、删除的或更新的每行都被转换成一条消息。</p>
<p>如果某一行频繁更新的话，同一个key就会存在多条消息(每次更新都会产生一条消息)。所幸的是，Kafka’s log compaction会对其进行排序，对以往的值进行garbage-collect处理，这样就不会浪费磁盘空间。另一方面，如果某一行从不更新或删除，在Kafka中也再也不会发生变化，-永远不会进行 garbage-collected.</p>
<p>整个数据库的备份和实时流位于同一个系统中是很有益处的。如果你想从头开始构建一个下游的系统，你可以从一个空的数据库开始，慢慢consuming Kafka topic，浏览所有的topic, 将每一条消息写入到你的数据库当中。完成之后，你便得到了整个数据的最新副本。另外，你可以通过不断的消费流数据来保持最新。给原有的数据做一些新的视图相当之容易。</p>
<p>用Kafka的方式来维护数据库的副本给熟悉传统的企业消息和局限性的人带来了诸多惊喜。事实上，这个应用场景也正是为什么Kafka是基于 <a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying" target="_blank" rel="external">replicated log abstraction</a>所构建的:它使得这样一类大规模的数据data retention and distribution 保持和分发成为了可能。下游系统可以自己的意愿重载和重新处理数据，不会影响要求低延迟查询的上游数据库的性能。</p>
<p><strong>为什么选择 Avro?</strong></p>
<p>从Postgres抽取的数据可以编码成JSON, or Protobuf, or Thrift,或其他任意格式. 但是，Avro才是最佳选择。Gwen Shapira 曾经撰文<a href="http://radar.oreilly.com/2014/11/the-problem-of-managing-schemas.html" target="_blank" rel="external">讨论了Avro在schema management中的优点</a>，我也写过一篇 <a href="http://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html" target="_blank" rel="external">Avro 与Protobuf and Thrift比较的文章</a> .<a href="http://blog.confluent.io/2015/02/25/stream-data-platform-2/" target="_blank" rel="external">Confluent流数据平台指南 stream data platform guide</a>中给出了为什么Avro 适合于数据集成的若干理由。</p>
<p>Bottled Water首先检查数据库表的schema，自动为每个表格生成Avro schema，利用<a href="http://confluent.io/docs/current/schema-registry/docs/index.html" target="_blank" rel="external">Confluent’s schema registry</a>对schema进行注册,将schema的版本嵌入到Avro中<br>以消息的形式发送给Kafka。也就是说是于流数据平台<a href="http://confluent.io/docs/current/schema-registry/docs/serializer-formatter.html" target="_blank" rel="external">serializers</a>一起使用:你可以将Postgres中拿到的数据以有价值的业务对象和丰富的数据类型来使用，无需编写大量的解析代码。</p>
<p>Postgres datatypes 到 Avro的转换已经基本上很全面了，涵盖了所有常见的数据类型，提供了一种lossless and sensibly的类型转换。后续我打算对其进行扩展以支持所有Postgres内置的数据类型-虽然工作量很大，但是是值得的，因为一个好的schema对于数据是相当重要的。</p>
<p><img src="../../../../images/slide-46-4-3-cropped.png" alt="Inside the bottle factory"></p>
<p><strong>logical decoding输出插件</strong></p>
<p> Postgres’ logical decoding feature的一个有趣之处在于说它并没有定义一种wire format来表示在网络中如何传输变更数据。相反，它定义了<a href="http://www.postgresql.org/docs/9.4/static/logicaldecoding-output-plugin.html" target="_blank" rel="external">output plugin API</a>, 其中对于每一次插入、更新或删除都会收到一个函数调用。 Bottled Water使用这个API来读取数据库内在格式的数据，并将其序列化成Avro格式。</p>
<p>由于 Postgres 扩展机制的原因，输出插件必须用C来编写，并且以共享库的形式导入到数据库服务器中去。这里要求使用超级用户的权限和数据库服务器的文件<br>访问权限，所以并不是很容易就完成的。这里我理解很多数据库管理会被在数据库服务器上运行自定义代码所吓到。不幸的是，这是目前能够使用logical decoding的唯一方式</p>
<p>所幸的是，你无须在主数据库中安装该插件-你可以使用从属机(replica, hot standby).这样你就能保证该插件不会损坏你的数据，引起主数据库的崩溃或影响其性能。</p>
<p><img src="../../../../images/slide-47-4-3.png" alt="Bottled Water architecture"></p>
<p><strong> client daemon</strong></p>
<p>除了数据库服务器上运行的插件之外, Bottled Water还包含了一个你可以在其他地方运行的客户端程序。它能够连接Postgres 服务器，能够连接 Kafka brokers，接收来自数据库的Avro格式编码的数据，将Avro数据推送给 Kafka。</p>
<p>客户端是使用C编写的，是因为这样使用Postgres 的客户端库文件的最简单的方式，由于客户端和插件之间一部分代码是复用的，相当轻量级，且无须写到磁盘中。</p>
<p>如果客户端发送崩溃，与Postgres or Kafka的连接发生中断会有哪些影响?完全没影响。它会跟踪那条消息已经发布过了，那条消息Kafka brokers已经确认过了。<br>当出错之后重启客户端时，它会重新发送哪些没有确认过的消息。因此Kafka 中一些消息可能会出现2次，但不会有数据丢失。</p>
<p><strong>相关工作</strong></p>
<p>其他人解决同样问题所做的工作:</p>
<ul>
<li><a href="https://github.com/xstevens/decoderbufs" target="_blank" rel="external">Decoderbufs</a>是一个试验性的Postgres plugin by <a href="https://twitter.com/xstevens" target="_blank" rel="external">Xavier Stevens</a>，将变更流转换成Protocol Buffers 格式.它只是提供 logical decoding plugin —并不包括一致性快照或客户端的部分 (Xavier提到他以前写过一个客户端，读取Postgres中的数据写到Kafka,但目前还不是开源的).</li>
<li><a href="https://github.com/xstevens/pg_kafka" target="_blank" rel="external">pg_kafka</a> (同样是Xavier写的) 是一个Postgres函数形式的Kafka producer client，你可以使用触发器来生成数据给Kafka</li>
<li><a href="https://wiki.postgresql.org/wiki/PGQ_Tutorial" target="_blank" rel="external">PGQ</a> 是一个基于Postgres的队列实现， <a href="https://wiki.postgresql.org/wiki/SkyTools" target="_blank" rel="external">Skytools Londiste</a> (developed at Skype)使用它来做基于触发器的复制。 <a href="https://bucardo.org/wiki/Bucardo" target="_blank" rel="external">Bucardo</a>是另一款基于触发器的复制器。就我理解基于触发器的复制是有些黑客味道的(相当有技术含量)，<br>要对schema进行变更，需要fiddly的配置，要承担巨额的花销。另外，这些项目似乎都没有得到PostgreSQL core team的认可,而 logical decoding is fully supported.</li>
<li><a href="http://sqoop.apache.org/" target="_blank" rel="external">Sqoop</a> 最近增加了支持<a href="https://issues.apache.org/jira/browse/SQOOP-1852" target="_blank" rel="external">writing to Kafka</a>. 就我所知，Sqoop只能利用数据库的完整快照，无法捕获持续的流数据，同样也无法保证不同快照之间的事务一致性</li>
<li>对于MySQL, <a href="https://twitter.com/lorax_james" target="_blank" rel="external">James Cheng</a>整理了从MySQL into Kafka的<a href="https://github.com/wushujames/mysql-cdc-projects/wiki" target="_blank" rel="external">change capture projects</a>的列表，这些项目主要围绕着binlog的解析，并没有做一致性快照的部分、</li>
</ul>
<p><strong>Bottled Water目前的状态</strong></p>
<p>目前, Bottled Water只是一款alpha的软件.充其量也就是个概念验证— 虽然经过了详细的设计和实现—但仍未在现实世界的系统中得到测试。现阶段还不适合在生产系统中使用，但经过一些测试和调整，希望将来能用在生产系统之中。</p>
<p>我们将其以开源的形式发布出来是希望能够得到社区的反馈。同时，知道我正在完成这个项目的人一直在帮我测bug。</p>
<p> <a href="https://github.com/confluentinc/bottledwater-pg/blob/master/README.md" target="_blank" rel="external">README</a> 包含了如何入门的更多信息。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/数据仓库/">数据仓库</a>►<a class="article-category-link" href="/categories/日记/数据仓库/KAFKA/">KAFKA</a>►<a class="article-category-link" href="/categories/日记/数据仓库/KAFKA/PostgreSQL/">PostgreSQL</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/KAFKA/">KAFKA</a><a href="/tags/PostgreSQL/">PostgreSQL</a><a href="/tags/数据仓库/">数据仓库</a><a href="/tags/日记/">日记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/26/from-relational-to-Kafka/" title="关系型数据库向KAFKA迁移 FROM RELATIONAL INTO KAFKA" itemprop="url">关系型数据库向KAFKA迁移 FROM RELATIONAL INTO KAFKA</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-04-26T06:19:12.000Z" itemprop="datePublished"> 发表于 Apr 26 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="关系型数据库向KAFKA迁移_FROM_RELATIONAL_INTO_KAFKA">关系型数据库向KAFKA迁移 FROM RELATIONAL INTO KAFKA</h2><p>英文版： <a href="http://ingest.tips/2015/04/26/from-relational-into-kafka/" target="_blank" rel="external">FROM RELATIONAL INTO KAFKA</a><br>中文版：<a href="http://wanghaisheng.github.io/2015/04/26/from-relational-to-Kafka" target="_blank" rel="external">关系型数据库向KAFKA迁移</a></p>
<p>去年我做了一个极受欢迎的“如何从数据仓库迁移到Hadoop”教程，大概内容可以在<a href="https://www.percona.com/live/mysql-conference-2014/sessions/relational-hadoop-migrating-your-data-pipeline" target="_blank" rel="external">percona 会议的网站上</a><br>看到。过去的四年我基本上都在和如何从传统ER数据库向Hadoop进行数据迁移打交道。<br>目前，我正在做的是，如何将数据从数据仓库迁移到 Kafka  。之前我就说过，Hadoop是一个性价比极高的数据仓库的解决方案。但Kafka不是数据仓库，即使你可以直接<br>用Hive查询Kafka的数据，数据访问的模式是有质的差异。Kafka 是一个很棒的管道和消息总线。</p>
<p>为什么要把数据从关系型数据库迁移到Kafka上呢？因为如果有上以千记的系统都想要访问关系型数据库中的数据，你绝对不想让每个app都能直接访问OLTP数据库 业务数据库<br>。一旦业务数据库down掉之后，会直接带来经济损失。</p>
<p>把数据从业务数据库中迁移到Kafka中来，这样大家就可以不影响DBA工作的情况下即可访问数据，更重要的是，完全用不到DBA。<br>要怎么实现数据从业务数据库中迁移到Kafka呢？如果你是个DBA，不了解什么是Kafka，可以看一下这个<a href="http://www.slideshare.net/gwenshap/kafka-for-dbas" target="_blank" rel="external">PPT:Kafka for DBAs</a><br>基本上有如下几种方式：</p>
<ul>
<li>1、<a href="http://sqoop.apache.org/" target="_blank" rel="external">Sqoop2</a>能够从支持JDBC的任何数据源把数据导入到Kafka中去。它是直接访问数据库的，你需要DBA的配合。</li>
<li>2、<a href="https://github.com/wushujames/mysql-cdc-projects/wiki" target="_blank" rel="external">MySQL到Kafka CDC</a>James Cheng总结了所有与MySQL到Kafka CDC之间数据迁移的项目。<br>基于MySQL CDC的方式是很安全的，系统是从数据库的事务日志中拿到数据，无需直接访问生产系统的库表。</li>
<li>3、<a href="https://github.com/confluentinc/bottledwater-pg" target="_blank" rel="external">bottledwater-pg</a>Martin Kleppmann的开源项目，利用Postgres事务日志将Postgres中的数据迁移到Kafka，具体介绍请参考<a href="http://blog.confluent.io/2015/04/23/bottled-water-real-time-integration-of-postgresql-and-kafka/" target="_blank" rel="external">Bottled Water: Real-time integration of PostgreSQL and Kafka</a>.其中导出的数据是Avro格式<br>保留了原始数据的schema，其他大部分项目都用的csv的文本格式。</li>
<li>4、对于Oracle的Redo日志而言，<a href="https://www.oracle.com/middleware/data-integration/goldengate/big-data/index.html" target="_blank" rel="external">GoldenGate</a><br>提供了一个Flume adapter但价格不菲，据说<a href="http://www.dbvisit.com/" target="_blank" rel="external">DBVisit</a>正在尝试使用自己的CDC的方式来解决数据从Oracle到Kafka的迁移</li>
</ul>
<p>等数据迁移到Kafka中的时候，可以做如下选择：</p>
<ul>
<li>1、使用一些如Cloudera Search, Elastisearch 的文本索引技术</li>
<li>2、使用流处理方式来处理数据，将其导入到NoSQL数据库当做物化视图来使用</li>
<li>3、转移至审计系统</li>
<li>4、转移至监控系统</li>
<li>3、在不同的Dashboard进行展示</li>
<li>3、用作系统缓存</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/数据仓库/">数据仓库</a>►<a class="article-category-link" href="/categories/日记/数据仓库/KAFKA/">KAFKA</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/KAFKA/">KAFKA</a><a href="/tags/数据仓库/">数据仓库</a><a href="/tags/日记/">日记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/04/11/patient-generated-data/" title="病人记录的健康信息PGHD" itemprop="url">病人记录的健康信息PGHD</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-04-11T13:40:12.000Z" itemprop="datePublished"> 发表于 Apr 11 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="病人记录的健康信息PGHD">病人记录的健康信息PGHD</h2><p>patient-generated health-information (PGHI) or patient-generated health data (PGHD). 这样一些在医院、医疗机构之外由患者或护理人员创建、收集、记录的与某个健康问题相关的观察、检验结果、 抑或是对已有EHR中某项数据的确认或变更等信息。</p>
<p>这样的信息在患者诊疗或健康管理过程中究竟应该扮演怎么样的角色？ONC在年底就他们所作的工作编制了这么一个报告，目录结构如下</p>
<p>一 问题是什么</p>
<p>1.临床中的PGHD</p>
<p>2.科研中的PGHD</p>
<p>3.政策上的PGHD</p>
<p>二机会在哪里</p>
<p>三有哪些顾虑</p>
<p>1.医疗机构的顾虑</p>
<p>2.患者的顾虑</p>
<p>3.技术因素</p>
<p>4.隐私与安全问题</p>
<p>四 下一步</p>
<p>整体报告<a href="images/pghd_brief_final122013.pdf">见文件</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/互联网医疗/">互联网医疗</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/PGHD/">PGHD</a><a href="/tags/互联网医疗/">互联网医疗</a><a href="/tags/日记/">日记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/23/service-principles/" title="Yelp公司总结的微服务架构的实践经验" itemprop="url">Yelp公司总结的微服务架构的实践经验</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-03-23T10:46:12.000Z" itemprop="datePublished"> 发表于 Mar 23 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="Yelp公司总结的微服务架构的实践经验">Yelp公司总结的微服务架构的实践经验</h2><p>英文版：<br><a href="(https://github.com/Yelp/service-principles">Service Principles</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/service-principles" target="_blank" rel="external">Yelp公司总结的微服务架构的实践经验/</a></p>
<h1 id="Service_Principles">Service Principles</h1><ul>
<li><a href="#service-principles">服务设计的原则</a><ul>
<li><a href="#creation">创建</a><ul>
<li><a href="#discuss-the-organization-of-your-overall-system-first">首先探讨系统的整体架构</a></li>
<li><a href="#check-whether-you-can-add-your-feature-to-an-existing-service">核实是否能够给现有服务添加新的功能</a></li>
<li><a href="#consider-whether-your-feature-is-better-suited-to-a-library">考虑你的功能是否更适合作为一个库</a></li>
<li><a href="#services-are-curated-by-teams-not-individuals">服务应由团队而不是个人负责管理</a></li>
<li><a href="#services-are-a-long-term-commitment">服务是长期的commitment</a></li>
<li><a href="#factor-in-the-overhead-of-deploying-a-distributed-system">部署到分布式系统之前的考虑因素</a></li>
<li><a href="#prefer-larger-services">服务大点更好</a></li>
<li><a href="#minimize-the-depth-of-the-service-call-graph">最小化服务调用链的深度</a></li>
<li><a href="#minimize-the-number-of-services-owned-by-your-team">最小化你的团队所拥有的服务数目</a></li>
</ul>
</li>
<li><a href="#interfaces">接口</a><ul>
<li><a href="#interfaces-should-be-easy-to-understand">接口要易于理解</a></li>
<li><a href="#interfaces-should-be-robust">接口要尽可能健壮</a></li>
<li><a href="#changes-to-interfaces-should-be-backwards-compatible">接口变更应该要向后兼容</a></li>
</ul>
</li>
<li><a href="#testing">测试</a><ul>
<li><a href="#any-changes-to-your-service-should-be-able-to-be-tested-automatically">应该能够对任何接口变更进行自动化测试</a></li>
<li><a href="#your-interface-is-the-most-important-thing-to-test">最主要的是测试你的接口</a></li>
</ul>
</li>
<li><a href="#operations">运维</a><ul>
<li><a href="#you-are-responsible-for-running-your-service">服务的运行由你来负责</a></li>
<li><a href="#guide-your-clients’-expectations">引导客户的期望值</a></li>
<li><a href="#plan-for-failure">故障计划</a></li>
</ul>
</li>
<li><a href="#additional-reading">补充材料</a></li>
</ul>
</li>
</ul>
<h2 id="创建">创建</h2><h3 id="首先探讨系统的整体架构">首先探讨系统的整体架构</h3><p>在你开始考虑设计服务之初，也就是动手写代码和设计之前，和团队成员、其他服务领域的专家聊一聊。除了如何与现有的特性、产品以及服务如何适配之外，考虑一下你想要额外添加的功能。考虑一种最合理的组织整体功能的方式。有时候添加新功能意味着要对现有组件进行重组。</p>
<p>我们希望避免那些简单的 “append-only”服务架构，也就是说development只存在于新的服务中 </p>
<h3 id="核实是否能够给现有服务添加新的功能">核实是否能够给现有服务添加新的功能</h3><p>在编写新的服务之前，应该核实是否现有服务不包括你的功能。它可能会与现有的功能存在冲突，处理相同的信息，或者只是在现有服务功能范围内的演化。另一方面，如果给现有服务添加新的功能会让服务的使用者感到困惑的话，最好就不要添加新的功能了。</p>
<h3 id="考虑你的功能是否更适合作为一个库">考虑你的功能是否更适合作为一个库</h3><p>尽管这篇文档是讲服务的，但值得注意的是一些功能更适合做成库。为了帮助大家更好的决策，我们介绍了库与服务之间进行取舍的一些经验:</p>
<p><strong><em>升级速度</em></strong>  对于库来讲更适合哪些用户期望很长时间才进行升级的场合(通常数周或数月，甚至于数年)。一般来说，这要求功能本身相对小且自包含，所以本身变更的可能就小。相反，如果你还正在进行开发，或者你希望能够快速推送一些bug修订给用户，这样的功能更适合作为一个服务。这样功能就回更复杂一些，常常需要依赖外部的一些库。</p>
<p><strong><em>性能和可靠性</em></strong> 库与调用请求的寻址空间一样，而服务则处于不同的网络地址。假使其他东西都是一样的，访问一个库 要比服务更快更可靠。但是，如果功能对资源需求较高，比如CPU,内存和硬盘，那么作为一个服务能够让客户端的运行效率更高，能够使得服务所依赖的硬件独立于客户端的硬件而水平扩展。</p>
<p><strong><em>技术无关性</em></strong><br>大多数情况下，Yelp使用的是Python，有一些后台服务是Java的。如果你的服务希望 Python and Java都能调用，那么做成服务能够帮你避免重复写两个库。</p>
<h3 id="服务应由团队而不是个人负责管理">服务应由团队而不是个人负责管理</h3><p>每个服务应由团队而不是个人负责管理，这样出了问题，就不会出现只有一个开发人员知道如何解决bug。实践中也就是说，每个服务从最开始都至少要2个人员参与，分摊维护的责任。</p>
<h3 id="服务是长期的投入">服务是长期的投入</h3><p>Services are a long-term commitment</p>
<p>当你编写代码时，你的团队会进行持续的维护和运营支持。随着时间推移，你的服务用户将依赖服务才能够运营。你需要持续的监控性能、一致性和 brown-outs.你或许也要处理下游系统的故障。</p>
<h3 id="部署到分布式系统之前的考虑因素">部署到分布式系统之前的考虑因素</h3><p>一个服务的推出往往花费的时间比你想象的要长。这可能是由于未预料到的不同服务间的交互，或者是搭建监控环境时的困难所导致的。负载测试没有100%完美的，因此需要部署成功之前制定一个多个阶段和迭代的持续计划。</p>
<h3 id="服务大点更好Prefer_larger_services">服务大点更好Prefer larger services</h3><p>尽量把相关功能整成一个较大的服务而非多个很小的服务。记住 你的大服务应该是逻辑内聚的，比如你仍然要具体的描述服务的功能。该原则的原理如下：</p>
<ul>
<li>流程内调用比服务间调用要更快、更可靠</li>
<li>单独更改一个服务比在多个服务间协调变更要简单一些。实际上，更改服务接口的成本相对是很高的</li>
<li>在运营层面上，保证统一的流程正常运行的话，数量越少越容易.</li>
<li>有些运维任务必须在每个服务上单独进行，比如库版本的更新。服务更少这个工作量越小</li>
</ul>
<h3 id="最小化服务调用链的深度">最小化服务调用链的深度</h3><p>在对服务进行架构时，调用链长度越小越好 (service <code>A</code> calls services <code>B</code>, <code>C</code> and <code>D</code>)比(<code>A</code> calls <code>B</code> calls <code>C</code> calls <code>D</code>)好。原理如下:</p>
<ul>
<li>更容易来推出调用链; 在长度较小的情况下, B, C and D 没有依赖任何外部的服务，而在较长的情况下B和C服务都依赖其他服务。注意 这与 <a href="http://en.wikipedia.org/wiki/Multitier_architecture#Three-tier_architecture" target="_blank" rel="external">three-tier architecture</a>很匹配。</li>
<li>这样能提高性能，在较短的情况下，服务的调用可以并发执行(只要服务间互相独立即可)而较长的情况下只能串行执行</li>
</ul>
<h3 id="最小化你的团队所拥有的服务数目">最小化你的团队所拥有的服务数目</h3><p>你所在的团队可能负责某个产品或一些产品的交付。你们所开发的服务应该与这一目标相统一。如果你们所拥有的服务过多，也就是说你的团队过于面面俱到，或者你们服务的统一程度还不够.</p>
<p>如果你们团队已经在负责大量的重要服务，且新功能并不属于任何已有的服务，在你们团队能够接受构建新服务的任务之前你可能需要把任务推出去。也应避免2个以上团队负责某个服务的情况</p>
<h2 id="接口">接口</h2><p>你的服务接口可能不只是对外发布的<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">REST</a> 接口. 日志、数据备份、数据流等其他服务使用的都要考虑在内。接口指的是对客户端有用的所有东西的总和.</p>
<blockquote>
<p>比如我们一直在模仿的接口设计的实践, 参考 <a href="https://developer.github.com/v3/" target="_blank" rel="external">GitHub API v3</a> 和  <a href="https://developer.paypal.com/docs/api/" target="_blank" rel="external">PayPal REST API</a></p>
</blockquote>
<h3 id="接口要易于理解">接口要易于理解</h3><p>在设计接口时, 要遵循如下最佳实践:</p>
<ul>
<li>使用自描述的名称。对内对外保持一直</li>
<li>让领域专家评审你的接口</li>
<li>使用一种显而易见的方式来完成每个操作</li>
<li>在将现有功能移植成服务时不一定会成为最好的网络节点。远端执行会改变一致性、可靠性和性能的本质。设计服务的边界时应保证与其他系统是松耦合的.</li>
<li>将读与更新操作的接口分离. (See <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" rel="external">CQRS</a> as an example)</li>
<li>尽可能的最小化、简单化你的接口。这样测试起来也方便</li>
<li>尽可能对存在疑虑的地方写上文档</li>
<li>跟自己发问: “在没有和你请教之前，新人能够看懂你的接口?”</li>
</ul>
<h3 id="接口要尽可能健壮">接口要尽可能健壮</h3><p>设计接口时把它当做是暴露给整个互联网来使用的。只暴露那些客户端需要的信息。尽可能不要提供不安全的、高成本的操作</p>
<p>将只读和能够改变状态的方法区分开来。理想情况下，只读方法是可缓存的且是幂等的</p>
<h3 id="接口变更应该要向后兼容">接口变更应该要向后兼容</h3><p>接口应该有某种版本控制机制。当改变一个服务接口时，之前存在的客户端仍然能够调用你之前版本的接口。你不能破坏这些客户端。要么做好计划持续的支持这些旧的客户端，要么花些时间使得它们和更新相协调。同时有多个版本的接口并存是可以接受的。</p>
<h2 id="测试">测试</h2><h3 id="应该能够对任何接口变更进行自动化测试">应该能够对任何接口变更进行自动化测试</h3><p>Yelp没有单独的QA工程师。相反我们靠计算机来进行校验工作。你的服务由你来负责维护测试工具。测试应该在开发和测试环境中都能够快速可靠的完成。</p>
<p>一个优秀的测试工具就像一个金字塔。最基础的是单元测试：很多快速的很小的测试代码中的单个实现的细节。中间一层是集成测试，这时候对服务进行交互的多个组件进行校验。最上面是很小但很重要的验收测试，主要校验你的服务是否能够与其他服务进行交互</p>
<h3 id="最主要的是测试你的接口">最主要的是测试你的接口</h3><p>接口是你们协议的重要部分，也就是客户端使用和交互的东西。如果你改变了接口，破坏或改变它原来的功能你会影响所有调用你服务的客户端。这个影响是很大的。</p>
<p>这也就是为什么接口测试是最主要的。接口测试能够告诉你客户端实际看到的是什么，持续的测试能够保证客户端总是看到这些结果。确保接口的所有现用版本的性能是一致的。尽可能早的编写测试，整个黑盒测试所看到的结果应该驱动你的接口设计</p>
<h2 id="运维">运维</h2><h3 id="服务的运行由你来负责">服务的运行由你来负责</h3><p>你的团队负责你们服务的持续运维。运维团队是解决整体站点问题的第一道防线，但是涉及到服务就只能做些边边角角的工作。监控服务的健康度是你的职责所在，做一些有意义的提醒以及出现问题时的方案。你是最了解服务运行机制的人，因此你也是发现和解决问题的最佳人选</p>
<p>为服务编写runbook。其中应包含常见的运维场景(诸如部署、监控和问题处理)。记录已知的错误。</p>
<h3 id="引导客户的诉求">引导客户的诉求</h3><p>你要能够准确清晰的向客户传达你们服务的运行特征。我们建议你要积极地监控和对服务进行测试以理解这些特征，以确保哪些你所承诺要达到的维护程度。</p>
<p>比如，如果我告诉客户99.99%的正常运行情况下99%的请求都在100ms以下。也就是说我要不停的监控性能和可用性来保证我的承诺。</p>
<p>不同服务运维承诺不同是可取的。a “cat picture of the day”服务的正常运行时间只是团队内部用来调剂气氛的就不需要实时的监控和提醒了。一个生产系统中的对主要节点很重要的服务就需要多关注正常运行时间、性能和其他可能会出现的问题</p>
<h3 id="故障计划">故障计划</h3><p>SOA的特质之一是分布式系统中故障场景数量的急剧增加。从运维角度来看，这意味着你的服务必须<br> strive to be honest about the collaborating services and datastores it requires to operate, and those whose downtime can be gracefully handled.</p>
<p>服务启动之初就要有如何确定外部的依赖关系和记录它们之间关系的计划。外部链接的指标，以及主动式和开发层面的保护措施以保障服务在外部故障之后的处理。最后一点，你要实时的监控这些潜在的weak points，根据严重程度来提醒当班团队.</p>
<p>另外，服务可能在跨机器、跨rack和跨数据中心间运行，每种情况都可能出现故障。要深刻理解这样的场景下服务的表型。</p>
<p>设计良好的服务要考虑所有的故障点，做出合理的决策来减少每个故障的可能性。</p>
<h2 id="补充材料">补充材料</h2><ul>
<li><a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="external">Martin Fowler on Microservices</a></li>
<li><a href="http://en.wikipedia.org/wiki/Law_of_Demeter" target="_blank" rel="external">Law of Demeter</a></li>
<li><a href="http://steverant.pen.io/" target="_blank" rel="external">Steve Yegge’s Google Platforms Rant</a></li>
<li><a href="http://en.wikipedia.org/wiki/Fallacies_of_distributed_computing" target="_blank" rel="external">The Fallacies of Distributed Computing</a></li>
<li><a href="http://pyvideo.org/video/2647/designing-poetic-apis" target="_blank" rel="external">Designing Poetic APIs</a></li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/架构/">架构</a>►<a class="article-category-link" href="/categories/日记/架构/微服务/">微服务</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/微服务/">微服务</a><a href="/tags/日记/">日记</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/23/adopting-microservices-at-netflix-lessons-for-team-and-process-design/" title="&lt;微服务架构在Netflix的应用&gt;系列博文-4 微服务架构在Netflix的应用：团队和流程设计相关的经验教训" itemprop="url">&lt;微服务架构在Netflix的应用&gt;系列博文-4 微服务架构在Netflix的应用：团队和流程设计相关的经验教训</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-03-23T03:37:12.000Z" itemprop="datePublished"> 发表于 Mar 23 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="第四篇-微服务架构在Netflix的应用：团队和流程设计相关的经验教训">第四篇-微服务架构在Netflix的应用：团队和流程设计相关的经验教训</h2><p>&lt;微服务架构在Netflix的应用&gt;系列博文-共四篇</p>
<p>英文版： <a href="(http://blogs.forrester.com/ted_schadler/13-11-20-mobile_needs_a_four_tier_engagement_platform/">第一部分： The Four-Tier Engagement Platform</a><br>中文版：<a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第一部分：移动应用所需要的四层架构/</a></p>
<p>英文版：<a href="http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/" target="_blank" rel="external">第二部分：http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/</a><br>中文版：<a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第二部分：是时候转移到四层架构上来了/</a></p>
<p>英文版：<a href="http://nginx.com/blog/microservices-at-netflix-architectural-best-practices/" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a><br>中文版：<a href="http://wanghaisheng.github.io/2015/03/23/microservices-at-netflix-architectural-best-practices" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a></p>
<p>英文版：<a href="http://nginx.com/blog/adopting-microservices-at-netflix-lessons-for-team-and-process-design/" target="_blank" rel="external">第四部分：Adopting Microservices at Netflix: Lessons for Team and Process Design</a><br>中文版：<a href="http://wanghaisheng.github.io/2015/03/23/adopting-microservices-at-netflix-lessons-for-team-and-process-design" target="_blank" rel="external">第四部分：微服务架构在Netflix的应用：团队和流程设计相关的经验教训</a></p>
<p>In a previous blog post, we shared best practices for designing a microservices architecture, based on Adrian Cockcroft’s presentation at nginx.conf2014 about his experience as Director of Web Engineering and then Cloud Architect at Netflix. In this follow-up post, we’ll review his recommendations for retooling your development team and processes for a smooth transition to microservices.<br>Optimize for Speed, not Efficiency</p>
<p>Source: Xyzproject@Dreamstime.com</p>
<p>The top lesson that Cockcroft learned at Netflix is that speed wins in the marketplace. If you ask any developer whether a slower development process is better, no one ever says yes. Nor do management or customers ever complain that your development cycle is too fast for them. The need for speed doesn’t just apply to tech companies, either: as software becomes increasingly ubiquitous on the Internet of Things – in cars, appliances, and sensors as well as mobile devices – companies that didn’t used to do software development at all now find that their success depends on being good at it.</p>
<p>Netflix made an early decision to optimize for speed. This refers specifically to tooling your software development process so that you can react quickly to what your customers want, or even better, can create innovative web experiences that attract customers. Speed means learning about your customers and giving them what they want at a faster pace than your competitors. By the time competitors are ready to challenge you in a specific way, you’ve moved on to the next set of improvements.</p>
<p>This approach turns the usual paradigm of optimizing for efficiency on its head. Efficiency generally means trying to control the overall flow of the development process to eliminate duplication of effort and avoid mistakes, with an eye to keeping costs down. The common result is that you end up focusing on savings instead of looking for opportunities that increase revenue.</p>
<p>In Cockcroft’s experience, if you say “I’m doing this because it’s more efficient,” the unintended result is that you’re slowing someone else down. This is not an encouragement to be wasteful, but you should optimize for speed first. Efficiency becomes secondary as you satisfy the constraint that you’re not slowing things down. The way you grow the business to be more efficient is to go faster.<br>Make Sure Your Assumptions are Still True</p>
<p>Many large companies that have enjoyed success in their market (we can call them incumbents) are finding themselves overtaken by nimbler, usually smaller, organizations (disruptors) that react much more quickly to changing consumer behavior. Their large size isn’t necessarily the root of the problem – Netflix is no longer a small company, for example. As Cockcroft sees it, the main cause of difficulty for industry incumbents is that they’re operating under business assumptions that are no longer true. Or, as Will Rogers put it,</p>
<pre><code>It’s <span class="keyword">not</span> what we don’t know <span class="keyword">that</span> hurts. It’s what we know <span class="keyword">that</span> ain’t so.”
</code></pre><p>Of course, you have to make assumptions as you formulate a business model, and then it makes sense to optimize your business practices around them. The danger comes from sticking with assumptions after they’re no longer true, which means you’re optimizing on the wrong thing. That’s when you become vulnerable to industry disruptors who are making the right assumptions and optimizations for the current business climate.</p>
<p>As examples, consider the following assumptions that hold sway at many incumbents. We’ll examine them further in the indicated sections and describe the approach Netflix adopted.</p>
<pre><code>Computing power <span class="keyword">is</span> expensive. This was <span class="keyword">true</span> when increasing your computing capacity required capital expenditure <span class="keyword">on</span> computer hardware. See Put Your Infrastructure <span class="keyword">in</span> the Cloud.
Process prevents problems. At many companies, the standard response <span class="keyword">to</span> something going wrong <span class="keyword">is</span> <span class="keyword">to</span> <span class="keyword">add</span> a preventative <span class="keyword">step</span> <span class="keyword">to</span> the relevant <span class="function"><span class="keyword">procedure</span>. <span class="title">See</span> <span class="title">Create</span> <span class="title">a</span> <span class="title">High</span> <span class="title">Freedom</span>, <span class="title">High</span> <span class="title">Responsibility</span> <span class="title">Culture</span> <span class="title">with</span> <span class="title">Less</span> <span class="title">Process</span>.</span>
</code></pre><p>Here are some ways to avoid holding onto assumptions that have passed their expiration date:</p>
<pre><code>As obvious <span class="keyword">as</span> <span class="keyword">it</span> might seem, you need <span class="keyword">to</span> make your assumptions explicit, <span class="keyword">then</span> periodically review them <span class="keyword">to</span> make sure they still hold <span class="constant">true</span>.
Keep aware <span class="keyword">of</span> technological trends. As an example, <span class="keyword">the</span> cost <span class="keyword">of</span> solid state storage drive (SSDs) storage continues <span class="keyword">to</span> go down. It’s still more expensive than regular disks, <span class="keyword">but</span> <span class="keyword">the</span> cost difference <span class="keyword">is</span> becoming small enough <span class="keyword">that</span> many companies are deciding <span class="keyword">the</span> superior performance <span class="keyword">is</span> worth paying a bit more <span class="keyword">for</span>. [Ed: In this entertaining video, Fastly founder <span class="keyword">and</span> CEO Artur Bergman explains why he believes SSDs are always <span class="keyword">the</span> right choice.]
Talk <span class="keyword">to</span> people who aren’t your customers. This <span class="keyword">is</span> especially necessary <span class="keyword">for</span> incumbents, who need <span class="keyword">to</span> make sure <span class="keyword">that</span> potential new customers are interested <span class="keyword">in</span> their product. Otherwise, they don’t hear <span class="keyword">about</span> <span class="keyword">the</span> fact <span class="keyword">that</span> they’re <span class="keyword">not</span> being used. As an example, <span class="keyword">some</span> vendors <span class="keyword">in</span> <span class="keyword">the</span> storage <span class="constant">space</span> are building hyper-converged systems even <span class="keyword">as</span> more <span class="keyword">and</span> more companies are storing their data <span class="keyword">in</span> <span class="keyword">the</span> cloud <span class="keyword">and</span> using open source storage management software. Netflix, <span class="keyword">for</span> example, stores data <span class="function_start"><span class="keyword">on</span></span> Amazon Web Services (AWS) servers <span class="keyword">with</span> SSDs <span class="keyword">and</span> manages <span class="keyword">it</span> <span class="keyword">with</span> Apache Cassandra. A single specialist <span class="keyword">in</span> Java distributed systems <span class="keyword">is</span> managing <span class="keyword">the</span> entire configuration <span class="keyword">without</span> any commercial storage tools <span class="keyword">or</span> help <span class="keyword">from</span> engineers specializing <span class="keyword">in</span> storage, SAN, <span class="keyword">or</span> backup.
Don’t base your future strategy <span class="function_start"><span class="keyword">on</span></span> current IT spending, <span class="keyword">but</span> instead <span class="function_start"><span class="keyword">on</span></span> level <span class="keyword">of</span> adoption <span class="keyword">by</span> developers. Suppose <span class="keyword">that</span> your company accounts <span class="keyword">for</span> nearly all spending <span class="keyword">in</span> <span class="keyword">the</span> market <span class="keyword">for</span> proprietary virtualization software, <span class="keyword">but</span> <span class="keyword">then</span> a competitor starts offering an open source-based product <span class="keyword">at</span> only <span class="number">1</span>% <span class="keyword">the</span> cost <span class="keyword">of</span> yours. If people start choosing <span class="keyword">it</span> <span class="keyword">instead of</span> your product, than <span class="keyword">at</span> <span class="keyword">the</span> point <span class="keyword">that</span> your share <span class="keyword">of</span> total spending <span class="keyword">is</span> still <span class="number">90</span>%, your market share has declined <span class="keyword">to</span> only <span class="number">10</span>%. If you’re only attending <span class="keyword">to</span> your revenue, <span class="keyword">it</span> seems like you’re still <span class="keyword">in</span> good shape, <span class="keyword">but</span> <span class="number">10</span>% <span class="keyword">of</span> market share can collapse really quickly.
</code></pre><p>Put Your Infrastructure in the Cloud<br>Source: Fbmadeira | Dreamstime.com</p>
<p>Source: Fbmadeira@Dreamstime.com</p>
<p>In Make Sure Your Assumptions are Still True, we mentioned that in the past it was valid to base your business plan on the assumption that computing power was expensive, because it was: the only way to increase your computing capacity was to buy computer hardware. You could then make money by using this expensive resource in the right way to solve customer problems.</p>
<p>The advent of cloud computing has pretty much completely invalidated this assumption. It is now possible to buy the amount of capacity you need when you need it, and to pay for only the time you actually use it. The new assumption you need to make is that (virtual) machines are ephemeral. You can create and destroy them at the touch of a button or a call to an API, without any need to negotiate with other departments in your company.</p>
<p>One way to think of this change is that the self-service cloud makes formerly impossible things instantaneous. All of Netflix’s engineers are in California, but they manage a worldwide infrastructure. The cloud enables them to experiment and determine whether (for example) adding servers in particular location improves performance. Suppose they notice problems with video delivery in Brazil. They can easily set up 100 cloud server instances in São Paulo within a couple hours. If after a week they determine that the difference in delivery speed and reliability isn’t large enought to justify the cost of the additional server instances, they can shut them down just as quickly and easily as they created them.</p>
<p>This kind of experiment would be so expensive with a traditional infrastructure that you would never attempt it. You would have to hire an agent in São Paulo to coordinate the project, find a data center, satisfy Brazilian government regulations, ship machines to Brazil, and so on. It would be six months before you could even run the test and find out that increased local capacity didn’t improve your delivery speed.<br>Create a High Freedom, High Responsibility Culture with Less Process</p>
<p>In Make Sure Your Assumptions are Still True, we observed that many companies create rules and processes to prevent problems. When someone makes a mistake, they add a rule to the HR manual that says “well, don’t do that again.” If you read some HR manuals from this perspective, you can extract a historical record of everything that went wrong at the company. When something goes wrong in the development process, the corresponding reaction is to add a new step to the procedure. The major problem with creating process to prevent problems is that over time you build up complex “scar tissue” processes that slow you down.</p>
<p>Netflix doesn’t have an HR manual. There is a single guideline: “Act in NetFlix’s best interest.” The idea is that if an employee can’t figure out how to interpret the guideline in a given situation, he or she doesn’t have enough judgment to work there. If you don’t trust the judgment of the people on your team, you have to ask why you’re employing them. It’s true that you’ll have to fire people occasionally for violating the guideline. Overall, the high level of mutual trust among members of a team, and across the company as a whole, becomes a strong binding force.</p>
<p>The following books outline new ways of thinking about process if you’re looking to transform your organization:</p>
<pre><code>The Goal: A Process <span class="operator">of</span> Ongoing Improvement <span class="keyword">by</span> Eliyahu M. Goldratt <span class="operator">and</span> Jeff Cox. This book has become <span class="operator">a</span> standard management <span class="keyword">text</span> <span class="keyword">at</span> business schools since its original publication <span class="operator">in</span> <span class="number">1984.</span> Written <span class="keyword">as</span> <span class="operator">a</span> novel about <span class="operator">a</span> manager who has only <span class="number">90</span> days <span class="built_in">to</span> improve performance <span class="keyword">at</span> his factory <span class="operator">or</span> have <span class="keyword">it</span> closed down, <span class="keyword">it</span> embodies Goldratt’s Theory <span class="operator">of</span> Constraints <span class="operator">in</span> <span class="operator">the</span> context <span class="operator">of</span> <span class="built_in">process</span> control <span class="operator">and</span> automation.
The Phoenix Project: A Novel about IT, DevOps, <span class="operator">and</span> Helping Your Business Win <span class="keyword">by</span> Gene Kim <span class="operator">and</span> Kevin Behr. As <span class="operator">the</span> title indicates, <span class="keyword">it</span>’s also <span class="operator">a</span> novel, about <span class="operator">an</span> IT manager who has <span class="number">90</span> days <span class="built_in">to</span> save <span class="operator">a</span> project that’s late <span class="operator">and</span> over budget, <span class="operator">or</span> his entire department will be outsourced. He discovers DevOps <span class="keyword">as</span> <span class="operator">the</span> solution <span class="built_in">to</span> his problem.
</code></pre><p>Replace Silos with Microservice Teams</p>
<p>Most software development groups are separated into silos, with no overlap of personnel between them. The standard process for a software development project starts with the product manager meeting with the user experience and development groups to discuss ideas for new features. After the idea is implemented in code, the code is passed to the quality assurance (QA) and database administration teams and discussed in more meetings. Communication with the system, network, and SAN administrators is often via tickets. The whole process tends to be slow and loaded with overhead.<br>silos-base</p>
<p>Source: Adrian Cockcroft</p>
<p>Some companies try to speed up by creating small “start-up”-style teams that handle the development process from end to end, or sometimes such teams are the result of acquisitions where the acquired company continues to run independently as a separate division. But if the small teams are still doing monolithic delivery, there are usually still handoffs between individuals or groups with responsibility for different functions. The process suffers from the same problems as monolithic delivery in larger companies – it’s simply not very efficient or agile.<br>Source: Adrian Cockcroft</p>
<p>Source: Adrian Cockcroft</p>
<p>Conway’s law says that the interface structure of a software system will reflect the social structure of the organization that produced it. So if you want to switch to a microservices architecture, you need to organize your staff into product teams and use DevOps methodology. There are no longer distinct product managers, UX managers, development managers, and so on, managing downward in their silos. There is a manager for each product feature (implemented as a microservice), who supervises a team that handles all aspects of software development for the microservice, from conception through deployment. The platform team provides infrastructure support that the product teams access via APIs. At Netflix, the platform team was mostly AWS in Seattle, with some Netflix-managed infrastructure layers built on top. But it doesn’t matter whether your cloud platform is in-house or public; the important thing is that it’s API-driven, self-service, and automatable.<br>Source: Adrian Cockcroft</p>
<p>Source: Adrian Cockcroft</p>
<p>Adopt Continuous Delivery, Guided by the OODA Loop</p>
<p>A siloed team organization is usually paired with monolithic delivery model, in which an integrated, multi-function application is released as a unit (often version-numbered) on a regular schedule. Most software development teams use this model initially because it is relatively simple and works well enough with a small number of developers (say, 50 or fewer). However, as the team grows it becomes a real issue when you discover a bug in one developer’s code during QA or production testing and the work of 99 other developers is blocked from release until the bug is fixed.</p>
<p>In 2009 Netflix adopted a continuous delivery model, which meshes perfectly with a microservices architecture. Each microservice represents a single product feature that can be updated independently of the other microservices and on its own schedule. Discovering a bug in a microservice has no effect on the release schedule of any other microservice. Continuous delivery relies on packaging microservices in standard containers. Netflix initially used AWS machine images (AMIs) and it was possible to deploy an update into a test or production environment in about 10 minutes. With Docker, that time is reduced even further, to mere seconds in some cases.</p>
<p>At Netflix, the conceptual framework for continuous development and delivery is an Observe-Orient-Decide-Act (OODA) loop.<br>Source: Adrian Cockcroft (<a href="http://www.slideshare.net/adrianco" target="_blank" rel="external">http://www.slideshare.net/adrianco</a>)</p>
<p>Source: Adrian Cockcroft (<a href="http://www.slideshare.net/adrianco" target="_blank" rel="external">http://www.slideshare.net/adrianco</a>)</p>
<p>Observe refers to examining your current status to look for places where you can innovate. You want your company culture to implicitly authorize anyone who notices an opportunity to start a project to exploit it. For example, you might notice what the diagram calls a “customer pain point”: a lot of people abandoning the registration process on your website when they reach a certain step. You can undertake a project to investigate why and fix the problem.</p>
<p>Orient refers to analyzing metrics to understand the reasons for the phenomena you’ve observed at the Observe point. Often this involves analyzing large amounts of unstructured data, such as log files; this is often referred to as big data analysis. The answers you’re looking for are not already in your business intelligence database. You’re examining data that no one has previously looked at and asking questions that haven’t been asked before.</p>
<p>Decide refers to developing and executing a project plan. Company culture is a big factor at this point. As previously discussed, in a high-freedom, high-responsibility culture you don’t need to get management approval before starting to make changes. You share your plan, but you don’t have to ask for permission.</p>
<p>Act refers to testing your solution and putting it into production. You deploy a microservice that includes your incremental feature to a cloud environment, where it’s automatically put into an AB test to compare it to the previous solution, side by side, for as long as it takes to collect the data that shows whether your approach is better. Cooperating microservices aren’t disrupted, and customers don’t see your changes unless they’re selected for the test. If your solution is better, you deploy it into production. It doesn’t have to be a big improvement, either. If the number of clients for your microservice is large enough, then even a fraction of a percent improvement (in response time, say) can be shown to be statistically valid, and the cumulative effect over time of many small changes can be significant.</p>
<p>Now you’re back at the Observe point. You don’t always have to perform all the steps or do them in strict order, either. The important characteristic of the process is that it enables you quickly to determine what your customers want and to create it for them. Cockcroft says “it’s hard not to win” if you’re basing your moves on enough data points and your competitors are making guesses that take months to be proven or disproven.</p>
<p>The state of art is to circle the loop every one to two weeks, but every microservice team can do it independently. With microservices you can go much faster because you’re not trying to get entire company going around the loop in lockstep.<br>How NGINX Plus Can Help</p>
<p>At NGINX we believe it’s crucial to your future success that you adopt a 4-tier application architecture in which applications are developed and deployed as sets of microservices. We hope the information we’ve shared in this post and its predecessor, Adopting Microservices at Netflix: Lessons for Architectural Design, are helpful as you plan your transition to today’s state-of-the-art architecture for application development.</p>
<p>When it’s time to deliver your apps, NGINX Plus offers an application delivery platform that provides the superior performance, reliability, and scalability your users expect. Fully adopting a microservices-based architecture is easier and more likely to succeed when you move to a single software tool for web serving, load balancing, and content caching. NGINX Plus combines those functions and more in one easy to deploy and manage package. Our approach empowers developers to define and control the flawless delivery of their microservices, while respecting the standards and best practices put into place by a platform team. Click here to learn more about how NGINX Plus can help your applications succeed.</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/架构/">架构</a>►<a class="article-category-link" href="/categories/日记/架构/微服务/">微服务</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/微服务/">微服务</a><a href="/tags/日记/">日记</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/23/microservices-at-netflix-architectural-best-practices/" title="&lt;微服务架构在Netflix的应用&gt;系列博文-3 微服务架构在Netflix的应用：架构设计的经验教训" itemprop="url">&lt;微服务架构在Netflix的应用&gt;系列博文-3 微服务架构在Netflix的应用：架构设计的经验教训</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-03-23T03:27:12.000Z" itemprop="datePublished"> 发表于 Mar 23 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="第三篇-微服务架构在Netflix的应用：架构设计的经验教训">第三篇-微服务架构在Netflix的应用：架构设计的经验教训</h2><p>&lt;微服务架构在Netflix的应用&gt;系列博文-共四篇</p>
<p>英文版： <a href="(http://blogs.forrester.com/ted_schadler/13-11-20-mobile_needs_a_four_tier_engagement_platform/">第一部分： The Four-Tier Engagement Platform</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第一部分：移动应用所需要的四层架构/</a></p>
<p>英文版： <a href="http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/" target="_blank" rel="external">第二部分：http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第二部分：是时候转移到四层架构上来了/</a></p>
<p>英文版： <a href="http://nginx.com/blog/microservices-at-netflix-architectural-best-practices/" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/microservices-at-netflix-architectural-best-practices" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a></p>
<p>英文版：<br><a href="http://nginx.com/blog/adopting-microservices-at-netflix-lessons-for-team-and-process-design/" target="_blank" rel="external">第四部分：Adopting Microservices at Netflix: Lessons for Team and Process Design </a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/adopting-microservices-at-netflix-lessons-for-team-and-process-design" target="_blank" rel="external">第四部分：微服务架构在Netflix的应用：团队和流程设计相关的经验教训</a></p>
<p>在最近的一些博客里我们解释了采用<a href="http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/" target="_blank" rel="external">四层的架构</a>对于开发和部署<a href="http://nginx.com/blog/building-microservices-free-ebook-oreilly-nginx/" target="_blank" rel="external">微服务</a>的应用程序是很重要的。<br>如果你仍然采用十年前的开发流程和应用架构，你不能很快地获取和满足移动端用户的需求，移动端用户可以从越来越多的APP中进行选择。</p>
<p>向微服务架构的转换给市场上的公司带来了很多的机会。对于系统架构和开发人员，它在为用户提供新的用户体验的同时又带来了一种前所未有的控制力和速度。但在现在这样紧张的节骨眼上，感觉上是不允许出一点差错的。现实世界中，你不可能革新期间就停止APP的开发和部署的。你深深明白未来的成功取决于能否成功迁移到微服务架构中来，但是你该怎么来做呢？</p>
<p><a href="http://nginx.com/wp-content/uploads/2015/02/Netflix_Logo_Digital-Video.png" target="_blank" rel="external"><img src="http://nginx.com/wp-content/uploads/2015/02/Netflix_Logo_Digital-Video-300x169.png" alt="Netflix_Logo_Digital+Video"></a></p>
<p>幸运的是，微服务的早期实践者本着开源的精神慷慨地分享他们的专业知识，不仅有开源代码，也会在会议上做一些演讲，写一些博客。Netflix就是其中之一。Adrian Cockcroft作为web工程和云计算架构师总监负责监督了公司内负责DVD租赁系统的100人的工程师团队从传统开发模式到只需要很少人员负责数百个后台服务的微服务架构来为数百万的Nrtflix客户提供数字娱乐服务。Battery Ventures公司的技术人员Cockcroft是微服务和云架构方面著名的布道者，目前供职于Nginx技术咨询委员会。<br>后续的两篇文章中，我们会给大家将一些从去年Cockcroft做的2场演讲，一场是10月的NGINX大会上，一场是几个月之后的硅谷微服务meetup中的一些启发。</p>
<ul>
<li>这篇里面主要是给微服务架构一个定义，阐述了一些设计微服务架构的最佳实践</li>
<li>后面的一篇讨论了采用软件设计新思路以及绕着这种新思路来重组团队的原因和方式。</li>
</ul>
<h2 id="什么是微服务架构?">什么是微服务架构?</h2><p>Cockcroft 把微服务架构定义为由松耦合的有相应语境的元素构成的一种面向服务的架构</p>
<p>松耦合意味着你可以独立更新这些服务。更新其中一个服务并不会改变其他的服务。<br>如果你的系统里有大量的特殊服务，但是又必须同时更新它们，它们又不是微服务，因为它们不是松耦合的。在向微服务迁移的时候人们常常会把数据库的耦合看的过重，也就是所有服务都连的是同一个数据库，更新其中一个服务就意味着要改变数据库的schema。这种情况你需要对数据库进行拆分</p>
<p><em>bounded contexts</em>的概念来源于Eric Evans的书 <em>Domain Driven Design</em> 。就软件开发的目的而言，拥有恰当语境的微服务本身是自包含的。由于微服务和其他微服务之间交互是严格通过API来进行的，你不需要共享数据结构、数据库表结构和对象的内部表达形式，在不了解其他服务的内部结构的情况下你也可以理解和更新一个微服务的代码。</p>
<p>如果你开发的是互联网应用，你已经很熟悉这些概念了，实际上只不过用的不是同样的叫法。大多数移动APP都用到了一些后台服务，这样用户可以在APP里实现Facebook里共享、从Google Map里得到地理位置、在Foursquare找到一家餐馆。假如你的APP与这些服务是紧耦合的，这样你在更新之前必须与开发团队进行协调来确保你的更新不会破坏任何东西。</p>
<p>在使用微服务架构时，你要把其他的开发团队看作是这些后台服务：也就是那些你的微服务通过API交互的外部服务。微服务之间最通用的协议就是它们的API足够稳定，也是向前兼容的。</p>
<p>就跟Google Map 的API不可能事先提醒就进行更改是不能所接受的，这样的话，你是API可以演进，但是必须要与之前的版本兼容</p>
<h2 id="微服务架构设计的最佳实践">微服务架构设计的最佳实践</h2><p>Cockcroft解释他在Netflix的职位是云架构师，他的职责不是管理架构，而是发现和标准化公司工程师所形成的架构。Netflix开发团队提出了几条设计和实现微服务架构的最佳实践</p>
<h3 id="每个微服务的数据单独存储">每个微服务的数据单独存储</h3><p> 不同微服务不要使用同一个后台数据存储。让开发团队选择适合每个微服务的数据库。或许，不同团队使用同样的数据结构来存储会减少工作量，但当其中某个团队想要更改数据结构的时候，其他服务不得不跟着改变。</p>
<p> 数据的拆分会使得数据管理异常复杂，是因为单独的存储系统不容易同步，易于出现不一致的情况，外键也会发生意外的改变。你需要一个后台运行的<a href="http://en.wikipedia.org/wiki/Master_data_management" target="_blank" rel="external">主数据管理</a>的工具来发现和修复不一致的情况。比如，你需要检查每个存储订阅者ID的数据库来确保所有的ID都是同一个。这个工具可以自己写或者直接买。很多商用的关系型数据库都提供此类核对，它常常过于耦合，不能支持很好的伸缩性。</p>
<h3 id="使用类似程度的成熟度来维护代码">使用类似程度的成熟度来维护代码</h3><p>微服务中所有代码都保持同样的类似程度的成熟度和稳定度。也就是说，你想要重写或给一个运行良好的已部署好的微服务添加一些代码的话，最好的方式常常 是对于新的或要改动的代码，新建一个微服务，现有的微服务丢着不管就行。 [编辑注：这种架构常常称之为<a href="http://highops.com/insights/immutable-infrastructure-what-is-it/" target="_blank" rel="external">immutable infrastructure</a> principle.] 这样的话，你可以迭代式的部署和测试新代码，直至没有bug，性能足够好,现有的微服务不会出现故障或性能下降.一旦新的微服务和原始的服务一样稳定，如果确实需要进行功能合并的话，你可以将其合并在一起，或者处于性能的考虑合并它们。然而，就Cockcroft’s的经验来讲，常常是你发现你的服务太大而要进行拆分。</p>
<h3 id="每个微服务都单独进行编译构建">每个微服务都单独进行编译构建</h3><p>每个微服务都单独进行编译构建，这样你就从代码库里某个版本中抽取单独的组件。这样，你可以拿到多个类似文件的微服务，但却是不同的版本的。这样如果要对codebase进行清理会比较麻烦，但对于在新建微服务时添加新文件时的便利性的话，是值得的。The asymmetry is intentional: 你想要引入新的微服务、文件或者功能，很容易又不会存在风险</p>
<h3 id="部署到容器之中">部署到容器之中</h3><p>将微服务部署到容器中很重要是因为这意味着你需要一款部署的工具。只要一个微服务是在容器之中，该工具就应该知道如何部署。无论是那种容器都没有关系。也就是说，Docker看起来很快会成为容器的行业标准。</p>
<h3 id="将服务器看做是无状态的">将服务器看做是无状态的</h3><p>将那些特别是部署了客户端代码的服务器视作是可替换的一组之中的一个。这些服务器的功能都是一样的，你无须关心某一个。只需要关心要实现你的目标是否数量足够，你可以使用自动伸缩来按需调整数目。如果其中一个服务器宕机了，可以由其他一个替换。避免了那些单个服务器完成特殊功能的系统中存在的雪崩现象，</p>
<p>Cockcroft打了个比方，你把服务器看做奶牛而不是宠物。如果生产系统中某个服务器负责某个特殊的功能，你通过名称认识这个服务器，这个服务器宕机后大家都回很难过，这也就是一个宠物。相反，如果你把服务器看作是一些奶牛。你关心的是你每天能挤多少奶，如果有一天你发现今天挤的奶少了，你知道是哪头牛有问题，你可以换掉它。</p>
<h2 id="Netflix_Delivery_Architecture_is_Built_on_nginx">Netflix Delivery Architecture is Built on nginx</h2><p>下面是一段软广吧。不过nginx还是很NB的。<br>Netflix is a longtime nginx user and became the first customer of NGINX, Inc. after it incorporated in 2011. Indeed, <a href="http://nginx.com/news/nginx-inc-consulted-netflix-open-connect-initiative/" target="_blank" rel="external">Netflix chose nginx</a> as the heart of their delivery infrastructure, the <a href="https://openconnect.itp.netflix.com/software/index.html" title="Open Connect Appliance Software" target="_blank" rel="external">Netflix Open Connect</a> Content Delivery Network (CDN), one of the largest CDNs in the world. With the ability to serve thousands, and sometimes millions, of requests per second, nginx is an optimal solution for high-performance HTTP delivery and enables companies like Netflix to offer high-quality digital experiences to millions of customers every day.<a name="videos"></a></p>
<h2 id="Video_Recordings">Video Recordings</h2><h3 id="Fast_Delivery">Fast Delivery</h3><p><a href="https://www.youtube.com/embed/5qJ_BibbMLw" target="_blank" rel="external">Fast Delivery nginx.conf2014, October 2014 </a></p>
<h3 id="Migrating_to_Microservices,_Part_1">Migrating to Microservices, Part 1</h3><p><a href="https://www.youtube.com/embed/1wiMLkXz26M" target="_blank" rel="external">Migrating to Microservices, Part 1 Silicon Valley Microservices Meetup, August 2014</a></p>
<h3 id="Migrating_to_Microservices,_Part_2">Migrating to Microservices, Part 2</h3><p>Silicon Valley Microservices Meetup, August 2014</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/架构/">架构</a>►<a class="article-category-link" href="/categories/日记/架构/微服务/">微服务</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/微服务/">微服务</a><a href="/tags/日记/">日记</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/23/time-to-move-to-a-four-tier-application-architecture/" title="&lt;微服务架构在Netflix的应用&gt;系列博文-2 是时候转移到四层架构上来了" itemprop="url">&lt;微服务架构在Netflix的应用&gt;系列博文-2 是时候转移到四层架构上来了</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-03-23T03:17:12.000Z" itemprop="datePublished"> 发表于 Mar 23 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="第二篇-是时候转移到四层架构上来了">第二篇-是时候转移到四层架构上来了</h2><p>&lt;微服务架构在Netflix的应用&gt;系列博文-共四篇</p>
<p>英文版： <a href="(http://blogs.forrester.com/ted_schadler/13-11-20-mobile_needs_a_four_tier_engagement_platform/">第一部分： The Four-Tier Engagement Platform</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第一部分：移动应用所需要的四层架构/</a></p>
<p>英文版： <a href="http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/" target="_blank" rel="external">第二部分：http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第二部分：是时候转移到四层架构上来了/</a></p>
<p>英文版： <a href="http://nginx.com/blog/microservices-at-netflix-architectural-best-practices/" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/microservices-at-netflix-architectural-best-practices" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a></p>
<p>英文版：<br><a href="http://nginx.com/blog/adopting-microservices-at-netflix-lessons-for-team-and-process-design/" target="_blank" rel="external">第四部分：Adopting Microservices at Netflix: Lessons for Team and Process Design </a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/adopting-microservices-at-netflix-lessons-for-team-and-process-design" target="_blank" rel="external">第四部分：微服务架构在Netflix的应用：团队和流程设计相关的经验教训</a></p>
<p>新年伊始，你也许计划提升你现有的数字化体验或者从头构建新的网站或系统。如果你要做这些都话，首要的你要牢记在心的是”web“不再只是指 ”web browser“。专家这些年一直在提”mobile first approach“来进行系统开发。但今年的移动流量已经增长至接近60%，这已经是不能再拖的了。互联式设备数量的激增，流量从桌面端向移动端的转变，万物互联的潮水意味着项目必须以不同设备上的用户体验为出发点。<br>过去的专注于单个集成式的包含大多数功能和特性的整体式模型-既往的应用架构开始不适合这个你需要根据特殊设备特殊用户来调整用户体验的年代。此外，你不能通过很多旧的架构模式和行为实现现如今的系统所要求的敏捷性、灵活性和可扩展性的要求。</p>
<p>为了开发和部署能够有效的吸引和留住不同设备上的移动端的APP，你需要有一种崭新的应用设计的思路。本文中将会阐述为何整体式的架构模型不再适用，同时介绍一种新的架构模型，能够帮助你迎接当今web，乃至于未来web的挑战。</p>
<h2 id="为什么软件架构的标准在变化">为什么软件架构的标准在变化</h2><p><img src="http://nginx.com/wp-content/uploads/2015/02/monolithic_architecture_post.png" alt=""><br>Monolithic Architecture, Source: Martin Fowler<br>在传统的 monolithic 架构中，应用程序处于中间那层，也就是说前端是展现层，后端是数据层。应用程序将数据传输给web浏览器，也就是展现层，它能给用户提供向应用程序请求信息、展现信息、管理和更改信息的方式，应用程序读写信息到数据层，数据层也就是数据库或其他存储设备负责管理和维护数据。应用程序本身负责与前后两层之间进行交互的业务逻辑以及数据的转换。</p>
<p> 并不是monolithic架构自身存在缺陷，只是它已经过时了，在智能手机和其他移动设备设计之前就已经存在了，那时候应用程序在展现层只需要跟一种实体进行交互，这种缺陷并不是由于层数亦或是层与层之间数据的处理方式，而是应用程序本身被写成一个单独的统一的代码块。monolithic的天性导致开发人员很难用敏捷性和灵活性对应用程序进行改造以适应移动终端用户的需求，满足运营团队自由伸缩应用程序规模以满足实际的需求。</p>
<p> monolithic 的设计理念阻碍了应用程序开发流程诸多阶段的敏捷性。即使应用程序的功能是以模块化方式组织的，人以模块的更改都需要对整个应用程序进行编译和测试。这本身是恨耗时的，对于那些一年内只更新很少次的公司来讲可能是可以接受的，但要跟上如今的大环境，一年只更新几次的APP恐怕难以在竞争中存活下来。你需要很快的响应渐进式的更新来为用户提供更好的性能和最新的功能。在这样的一个世界里，更新APP永远不会给大多数用户带来不便。</p>
<p>Source: Martin Fowler</p>
<p><img src="http://nginx.com/wp-content/uploads/2015/02/microservices_architecture_post.png" alt=""><br>Microservices Architecture, Source: Martin Fowler</p>
<p> 将应用程序拆分成模块长久以来被视为最佳实践。最近，开源项目的成功使得多数开发人员能够借助外部的一些库来实现特殊的功能。这些开源库常常用于那些开发人员不熟悉的特殊功能，或仅仅是为了节省时间，或者是出于维护安全性的考虑。对于 monolithic设计而言 就不存在从诸多方案中任选其一的灵活性，应用程序往往是由一些高度耦合的组件开发而成。</p>
<p> 最后一点，三层架构缺乏伸缩性。事实上，提出这种架构理念的年代并不存在 elasticity and rapid scaling 。由于应用程序的功能组件是打包成一个整体的，你要响应客户端需求变更的唯一方式就是对整体进行扩展。由于应用程序是紧耦合的，三层架构的应用程序通常是没有办法对某个特殊部分单独进行扩展的。不管是一个电子商务的平台、社交媒体的应用还是一个博客，现如今应用程序的基本要求是能够按需伸缩，成本越低越好。对应用程序进行伸缩控制的过程要简单、自动化和智能。比如说某个应用架构能够让你根据用户注册的突发量来部署额外的Node.js节点。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/架构/">架构</a>►<a class="article-category-link" href="/categories/日记/架构/微服务/">微服务</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/微服务/">微服务</a><a href="/tags/日记/">日记</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/03/23/mobile_needs_a_four_tier_engagement_platform/" title="&lt;微服务架构在Netflix的应用&gt;系列博文-1 移动应用所需要的四层架构" itemprop="url">&lt;微服务架构在Netflix的应用&gt;系列博文-1 移动应用所需要的四层架构</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-03-23T03:17:12.000Z" itemprop="datePublished"> 发表于 Mar 23 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="第一篇-移动应用所需要的四层架构">第一篇-移动应用所需要的四层架构</h2><p>&lt;微服务架构在Netflix的应用&gt;系列博文-共四篇</p>
<p>英文版： <a href="(http://blogs.forrester.com/ted_schadler/13-11-20-mobile_needs_a_four_tier_engagement_platform/">第一部分： The Four-Tier Engagement Platform</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第一部分：移动应用所需要的四层架构/</a></p>
<p>英文版： <a href="http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/" target="_blank" rel="external">第二部分：http://nginx.com/blog/time-to-move-to-a-four-tier-application-architecture/</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/time-to-move-to-a-four-tier-application-architecture" target="_blank" rel="external">第二部分：是时候转移到四层架构上来了/</a></p>
<p>英文版： <a href="http://nginx.com/blog/microservices-at-netflix-architectural-best-practices/" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/microservices-at-netflix-architectural-best-practices" target="_blank" rel="external">第三部分：微服务架构在Netflix的应用：架构设计的经验教训</a></p>
<p>英文版：<br><a href="http://nginx.com/blog/adopting-microservices-at-netflix-lessons-for-team-and-process-design/" target="_blank" rel="external">第四部分：Adopting Microservices at Netflix: Lessons for Team and Process Design </a><br>中文版：<br><a href="http://wanghaisheng.github.io/2015/03/23/adopting-microservices-at-netflix-lessons-for-team-and-process-design" target="_blank" rel="external">第四部分：微服务架构在Netflix的应用：团队和流程设计相关的经验教训</a></p>
<p>Michael Facemire, John McCarthy和作者最近向整个软件技术行业发起了倡议：老式的web不是为移动APP和网站而设计的，也不能处理互联式产品的实时需求。是时候提出一种新架构了。</p>
<p>大致总结如下:</p>
<p>移动互联网把传统的web架构推到了悬崖的边缘。为传统PC的浏览器而设计的三层架构不够灵活，不能很好地扩展，也不能提供良好的移动端的用户体验，满足互联式产品的新兴需求。移动互联网的volatility and velocity of change需要的是一种分布式的四层架构，我们称之为“engagement platform”。<br>这个平台能够将技术功能分成4部分：客户端、分发端、集成聚合端、和服务端。</p>
<p>移动互联网APP的新需求需要将CDN、应用服务器供应商、移动端中间件供应商、PAAS供应商、各种初创公司和其他公司围绕着这四层架构整合起来。<br>CIO需要立即规划从三层架构到四层架构的迁移工作。</p>
<p>是时候扔掉三层架构，即表现层、应用层和数据层，转向能够满足新需求的四层架构模型：</p>
<blockquote>
<p>“engagement platform”支持分布式的四层架构，能够提供优质的用户体验、优异的性能，以及与任何设备之间的模块化集成。</p>
</blockquote>
<p>Figure 1 The Four-Tier Engagement Platform Makes Delivery Its Own Tier<br><img src="http://blogs.forrester.com/f/b/users/TSCHADLER/engagement_platform_2.png" alt=""></p>
<p>四层架构的处理流程如下:</p>
<ul>
<li>客户端层负责不同设备的唯一性的确定。 这一展现层将每个app以及设备(桌面端、移动端，浏览器或原生APP)的特殊功能与后台应用程序的服务隔离起来。这个边界使得开发人员可以将后台服务的开发与消费它们的app独立开来，比如航班状态和入港通知等等。确定明确的边界提高了开发人员的效率，无需顾及繁重的维护工作，一个良好的网络环境也是很重要的。</li>
<li>分发层处理中间的和最后一英里的问题。通过客户端层的信息决定交付特定场景下具体内容的最佳方式。通过over-the-wire的内容转换—这里与聚合层不同，聚合层使用的基于协议的转换，利用 edge-of-network cache 功能来增加动态数据， 如Akamar等提供的CDN、如Instart Logic的分发优化方案、如Riverbed Stingray的应用分发控制和on-premises in-memory database caches一起完成这方面的任务</li>
<li>聚合层负责内部和外部服务的集成和数据的转换。这样的API层有两方面的角色，不同APP请求和服务<br>的发现和客户端请求与后台服务的双向转换。这样能够使得底层数据的组装和服务更加简洁，能够提供相对实时的数据格式的转换。服务组合外加上商务智能、分析、基于角色的访问等更加动态。</li>
<li>服务层包括了内部外部提供数据和功能。通过一系列连贯的可部署的服务来动态组装服务和业务流程。<br>该层负责为上述三层提供数据，不关心数据具体如何使用。其他几层可以部署在防火墙内也可以部署在防火墙外，或者二种方式相结合。这样不论是APP使用还是生态系统中其他系统使用，在服务的动态组合和访问上就提供了相当的灵活性</li>
</ul>
<p>未来的展望</p>
<p>问: 如果未来是engagement platform的天下，如何实现呢？</p>
<p>答: 颠覆现在的软件行业的核心架构。IBM, Microsoft, Oracle, and Akamai一直在推三层架构，现在将被<br>Netflix, Kinvey, and Salesforce.com提出的四层架构所替代。</p>
<p>是时候供应商、投资人员、架构师和开发人员对如何来构建和使用engagement platform展开讨论了。</p>
<p>engagement platform”支持分布式的四层架构，能够提供优质的用户体验、优异的性能，以及与任何设备之间的模块化集成，并且能够推动这些颠覆的演化:</p>
<ul>
<li>公司将依赖于供应商的生态系统来deliver engagement. 你无须购买这个engagement platform平台。而且这个engagement platform平台也不是全部受你直接控制。相反，你以松耦合的方式组装各种<br>engagement 功能，而且能够按需扩展，同时能够保持灵活性，也能够解决持续交付的问题。</li>
<li>HTTP traffic on Nginx will surpass the traffic on Apache. If you don’t know what those things are, don’t worry about it. If you don’t but think you should, then see the last chart here and learn about it here and here.</li>
<li>IBM, Oracle, Microsoft, SAP, and Salesforce.com will rethink their middleware products and architectures. Adding mobile app lipstick on an application server won’t solve the delivery challenge by itself. These companies will slowly overcome their reluctance and begin to operate in a four-tier, ecosystem-dependent platform. But it will take five years for that to happen. Microsoft Azure is the farthest along, but still tentative in its strategy and execution.</li>
<li>The content delivery network industry will accumulate content and performance optimization services. Akamai, Limelight, and Amazon CloudFront have done good work for the Web. But new approaches from Instart Logic and rumblings from Akamai point to the delivery-tier future.</li>
<li>Platform-as-a-service providers like Amazon, Google, IBM, Microsoft, and Salesforce will grow many new platform services. For example, services in the aggregation tier loosely coupled with an intelligent delivery tier will handle notification at scale, including personalized messages, open-message analytics, and device and network customization.</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/架构/">架构</a>►<a class="article-category-link" href="/categories/日记/架构/微服务/">微服务</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/微服务/">微服务</a><a href="/tags/日记/">日记</a><a href="/tags/架构/">架构</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/09/web-api-from-start-finish-2/" title="读&lt; 从业务角度看API &gt;" itemprop="url">读&lt; 从业务角度看API &gt;</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-02-09T05:42:12.000Z" itemprop="datePublished"> 发表于 Feb 9 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="第二篇，读&lt;_从业务角度看API_&gt;">第二篇，读&lt; 从业务角度看API &gt;</h2><p><a href="http://www.infoq.com/articles/web-apis-business-perspective" target="_blank" rel="external">英文</a><br><a href="">中文</a><br>作者：Matt McLarty</p>
<p>观点1：API是当今信息技术趋势的核心，比如说移动终端、云计算、物联网、大数据、社交网络。涉足各行各业，如能源、汽车、电商等<br>观点2：虽然和API在整个技术领域应用相比是九牛一毛，在open WEB领域，API俨然已经成为相当重要的创新和收益的业务模式，对比，Kin Lane在<a href="http://apievangelist.com/index.html" target="_blank" rel="external">API Evangelist</a>网站上撰文进行了详细的阐述, <a href="https://medium.com/@medjawii/5-ways-an-api-is-more-than-an-api-bddcdb0517ca" target="_blank" rel="external">Mehdi Medjaoui</a>也在博文中就此进行了总结 。<br>事实上，现如今web API是隐藏在解决方案背后的，也就是API的业务模式也就是业务本身<br>观点3：API的业务价值、商业价值是可以度量的。传统意义上，由于服务器和存储设备成本高昂，他们所拥有的数据一定程度成为自身的债务。现如今，伴随着大数据和物联网、万物互联IoT等技术发展，拥有数据意味着可以将其转换为新的机会和收入来源。<br>观点4：如何确定那些数据、服务可以通过API暴露，以及如何实现这些API，可以通过如下三个数据的属性来判断：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Applicability</td>
<td><ul><li>这些数据是否能够帮助我们实现核心业务价值</li><li>这些数据是否能够形成业务上的差异性</li><li>需要那些商品化处理才能将这些数据对外发布</li></ul></td>
</tr>
<tr>
<td>Data Accuracy</td>
<td><ul><li>目前这些数据的及时性如何</li><li>数据是否来自可信的来源</li><li>正确的用户出于正确的目的是否可以访问数据</li></ul></td>
</tr>
<tr>
<td>Data Accessibility</td>
<td><ul><li>有哪些数据可供程序使用</li><li>这些数据有哪些不同的访问方式</li><li>开发人员利用这些数据构建APP的难易程度如何</li><li>数据访问的规模是否能满足客户的需求</li></ul></td>
</tr>
</tbody>
</table>
<p>总结下来，也就是两方面：<br>1、有用的API“Useful APIs”  能够提供准确适当的数据<br>2、可用的API “Usable APIs”能够访问到数据</p>
<p>观点5：有用的API<br>开发API时常见的误区是认为所有数据都是有用的。不是说你开放了数据，开发人员就能从中增加收益、创新、开拓新的业务。API和Open Data本身是远远不够的。<br>“This “medium is the message” thinking was responsible for many of the failed SOA initiatives that occurred in enterprise integration over the last decade”这句是什么意思，没有搞懂<br>举出Google  Map、Facebook、Twitter的例子说明只有正确的数据结合API才能攫取最大的效益，<br>观点6：Amazon API的案例<br>API对于开放API之外的机构而言，在业务上帮助作用拥有巨大潜力。对于Amazon，API是从内部缘起的。<br>经验教训一：将API定位为产品、解决方案的构建基石。Brad Stone在<a href="http://brad-stone.com/book/" target="_blank" rel="external"></a>书中花了一章来阐述API是Amazon整个技术架构的基础，Kin Lane在博文<a href="http://apievangelist.com/2012/01/12/the-secret-to-amazons-success-internal-apis/" target="_blank" rel="external">The Secret to Amazons Success Internal APIs</a>中讨论了如何保证程序能够访问这些API接口。<br>经验教训二：如何使用基于API的方法来采集、分析、改进和分发数据。Jeff Bezos 讲到<a href="http://www.businessinsider.com/bezos-pioneering-requires-being-misunderstood-2013-1" target="_blank" rel="external">“We don’t make money when we sell things. We make money when we help customers make purchase decisions.”</a>.只有恰当的、准确的、可用的数据才能帮助用户进行决策，这对于亚马逊来讲至关重要。<br>“Data-Enabled Disruption (DED)”图示<br><img src="../../../../images/DED_Cycle.jpg" alt=""><br>经验教训三： 战略与战术定位之间的权衡。早期，Jeff Bezos认识到万维网的巨大潜力，随即产生了要创建一个巨大的能够存放任何东西的商店。<br>在分析了市场之后，以在线图书零售为突破口来优化整个供应链，企业文化(ensuring timely execution while maintaining religious devotion to the future vision—is now a tenet of Amazon’s culture, where solutions must add value both in what they deliver and what they enable)一方面能够实现功能，一方面能够传递价值。<br>见下图<br><img src="../../../../images/5Fig2.png" alt=""><br>每种服务都对应着一个API，每个都是基于早期的解决方案所产生的。</p>
<p>观点6：可用的API以及API设计的重要性<br>虽然亚马逊很成功，但它们的API设计却不是很好，也不易用。随着API的爆发性增长和其必要性的认可度提高，API的可用性成为众多公司主宰行业或者初创公司试图开拓创新服务的关键。</p>
<p>移动设备和consumerization of IT引发了企业应用开发的<a href="https://www.linkedin.com/today/post/article/20140716032508-16039030-the-rebirthing-of-the-mobile-app?trk=hb_ntf_MEGAPHONE_ARTICLE_POST" target="_blank" rel="external">模式转变</a>。从一开始的终端到CS架构到现在的分布式网络。在之前的文章<a href="https://www.youtube.com/watch?v=23nyxjRPe94" target="_blank" rel="external">the shedding of tiers</a>,为了适应云端和移动端的发展，正在从n层web模型向以API为中心的而转变。<br>以远程通讯领域为例，多年来大玩家们一方面互相竞争，另一方面寻求能够为用户提供网络之外的增值服务。这个行业在过去15年间经历过很大分裂，如VOIP的出现，业务和服务的整合，以及移动设备服务的改革，在上述环节中，API都发挥了作用，尽管仍然主导着传统的telco服务，但难以维系其优势，在Alan Quayle的文章<a href="">a-brief-history-of-telco-apis</a>(<a href="http://alanquayle.com/2012/06/a-brief-history-of-telco-apis/)中指出在像Parlay" target="_blank" rel="external">http://alanquayle.com/2012/06/a-brief-history-of-telco-apis/)中指出在像Parlay</a> X和OneAPI这样的协作项目中这些玩家困难重重。</p>
<p>Twilio公司成立于2007年，旨在提供易用的语音和短信服务，所有应用都部署在云端。他们认识到API是他们最核心的业务渠道，尽管SMS和VOIP服务是恨有用的，但要和大玩家竞争，commoditized telco services是远远不够的。Twilio也意识到他们服务的最初用户并非终端用户，而是调用API构建APP的开发人员，而且发展最快的是移动APP，于是开发了诸多衡量是否能够很好的服务客户的指标。除了像传统的统计数据如端到端的调用响应时间，他们还测量了新上手的开发人员从注册他们的api到开发好应用花多长时间，这极大的提高了易用性，成为了和大公司的主要差异点，当开发人员在选择SMS VOIP服务的时候，优势就显现出来了。</p>
<p>总结：<br>1、API 与业务策略要统一<br>2、实现过程中通过API保证数据可用、准确<br>3、确保API是有用的、可用的<br>4、像亚马逊一样形成a disciplined culture of iterative Data-Enabled Disruption<br>5、像Twilio一样形成优质的API开发人员用户体验来差异化和竞争对手的业务</p>
<p>参考资料</p>
<p><a href="https://medium.com/@medjawii/5-ways-an-api-is-more-than-an-api-bddcdb0517ca" target="_blank" rel="external">Mehdi Medjaoui</a></p>
<blockquote>
<p>如果要解释web API到底是什么，常常会说，“web API代表的是应用程序的借口”，这个答案会让business managers和出租车司机都一脸茫然。如果说“是网站和移动应用程序的基石”，又显得太过于抽象，如果说“你记得Facebook和微信上的点赞按钮么，可用在Facebook之外的任何网站上使用，那么Facebook是如何知道发生了什么 的呢？这一切要归功于Facebook的API使得外部网站和Facebook能够处于连接状态。因此点赞按钮是不属于Facebook本身的Facebook的一块功能，API能够似的应用程序相互连接起来”<br>如果Twitter不允许收集APP访问Twitter你如何从收集发送tweet，也就是说APP也要用到Twitter的API。<br>这些说法都没错，我们强调了API是一切事物的基石。但对于CEO和管理层而言，API对于业务有多大价值，如何来介绍呢<br>“An API is not only a building brick, it is also a projection of a product vision, based on internal assets you can open to the world”<br>API定义了一种新的数字化的B2B共享的生态圈，各个公司以API的形式将自己的核心资产暴露出去，同时通过API消费其他核心资产。对于管理、业务人员我们要向他们这样解释，将内部资产以web API暴露出去，也就成为了第三方可产品化的资产。这时候，API 就是产品。<br>那如何从市场、财务、技术、业务拓展和法律五个角度来解释API呢？<br>第一点：平台式思考。就市场而言，开放API意味着公司转型为一个平台，在传统的B2B或SaaS市场上，你与竞争对手在同一个市场上竞争，很难扩展市场份额。<br><img src="../../../../images/typical-market-share.png" alt=""><br>通过Open API，你占领的是垂直方向的市场，与合作方和第三方以及开发人员形成一个全新的生态圈，蓝海市场。<br><img src="../../../../images/blue-ocean.png" alt=""><br>第二点：现有资产的商品化。从财务的角度来看，API是对现有资产ROI做乘法。在亚马逊形成了一个全球性的零售店之后，才发觉他们自己的云数据服务器架构也可以作为服务来卖，通信行业采用了双面的业务模型，一方面卖自己的语音、短消息和连接服务，另一方面卖自己的网络给第三方公司。最近IBM也开始对外卖自己的Watson大数据处理分析技术。<br>对于花了重金形成了技术资产的公司，也想通过向第三方开放的形式回收一部分投入。就好像你买了一栋房子，想出租其中一间给外人来用抵房贷一样。</p>
</blockquote>
<p>第三点：Composability 从技术的角度而言，API能够让用户把外部的软件适配到自己内部的IT架构上，而不是反过来内部的IT架构适配外部的软件上。<br>在做B2B集成时，必须考虑尽量避免自己这边的繁重的governance治理工作量。再也没有必要安排一系列的业务上的会议、技术上的会议和技术培训来探讨如何集成。可以在自己的网站上把API放上去，能够极大地帮你减少概念验证所花的时间。客户只需要通过API把你的软件与自己内部的IT架构整合起来，不用说两面都添功能，再改功能。<br>当然你也可以给客户直接买实现好的服务，虽然大多数长尾客户都会自己实现自己的功能。</p>
<p>第四点：自服务Self-service，从业务拓展的角度而言，API就是一个Self-service自服务的门户，能够让你的业务延伸到全球范围内。潜在的用户能够7*24小时的发现你所提供的服务和特性，使用API来完成集成，letting you contact them later in the customer on-boarding funnel. You are then able to transform better leads into customers in a more qualified approach</p>
<p><img src="../../../../images/self-service.png" alt=""></p>
<p>越来越多的开发人员代表公司会在查找API，立即进行集成的测试，在评估线上可用的服务之后做出业务上的决策。有人曾说过如果开发人员不能马上开始集成的话，在7分钟内就会转向另一个API服务，作者也听过很多客户讲过如果服务不能在他们所在的时区内启动和运行的话，或者是晚上或是周末，或者说要去解决针对他们自己业务需求的一些问题的话，客户都会直接抛弃这个API。</p>
<p>第五点：从法律的角度而言，API就是供应方和客户之间的一纸合约。这个在API Terms of Service and Business Model Agreement.的里面都说明好了。<br>API式的业务数据定义了两个机构/实体间的业务和法律关系：它是供应方和客户之间的合同。<br>This is why an API user and customer community is valuable as a customer portfolio in accounting.<br>因此，从法律角度来看，API就是合同，但是相对简单，十分钟就可以读完；同样也是7*24小时可用；足够灵活可随生态系统的发展而改变；</p>
<p>总结：<br>API的出现改变了我们做生意的方式，但很重要的一点是形成一个真正理解API真正价值的业务文化。通过向周围的同事介绍宣讲API到底是什么，鼓励大家实践API。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/HTTP-API/">HTTP API</a>►<a class="article-category-link" href="/categories/日记/HTTP-API/REST/">REST</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/HTTP-API/">HTTP API</a><a href="/tags/REST/">REST</a><a href="/tags/日记/">日记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/08/web-api-from-start-finish-1/" title="读&lt; 与Roy Fielding谈论版本化、超媒体以及REST &gt;" itemprop="url">读&lt; 与Roy Fielding谈论版本化、超媒体以及REST &gt;</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/111190881341800840000?rel=author" title="Edwin" target="_blank" itemprop="author">Edwin</a>
		
  <p class="article-time">
    <time datetime="2015-02-08T03:34:12.000Z" itemprop="datePublished"> 发表于 Feb 8 2015</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>版权声明：<br>欢迎转载本站的所有内容，本站的所有文章使用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议</a>，唯一的要求就是保留署名权，请在转载时注明出处。</p>
</blockquote>
<h2 id="第一篇，读&lt;_与Roy_Fielding谈论版本化、超媒体以及REST_&gt;">第一篇，读&lt; 与Roy Fielding谈论版本化、超媒体以及REST &gt;</h2><p>全系列<a href="http://www.infoq.com/articles/Web-APIs-From-Start-to-Finish" target="_blank" rel="external">Web APIs: From Start to Finish </a><br>第一篇，读&lt; 与Roy Fielding谈论版本化、超媒体以及REST &gt;<br><a href="http://www.infoq.com/cn/articles/roy-fielding-on-versioning" target="_blank" rel="external">中文版</a><br><a href="http://www.infoq.com/articles/roy-fielding-on-versioning" target="_blank" rel="external">英文版</a><br>Roy的“Scrambled Eggs • Roy T. Fielding, Ph.D. | Senior Principal Scientist, Adobe”PPT解读<br>1、什么是作者所说的版本化，怎么理解所说的接口数量限制在某些名称内，什么样的名称，还有一点是这里所说的API版本和资源的版本的区别是什么，各自的设计初衷是什么，适用的场景有哪些？</p>
<blockquote>
<p>我所说的版本化，是指将客户端可见的接口数量限定在某些名称内，这样一来客户端就可以对每个操作进行标记，将这些操作归于该API的某一版本。</p>
</blockquote>
<p>不幸的是，对接口名称进行版本化，只是从API作者的角度而言实现了对变更的管理。这一点是对接口设计哲学的短视行为：作者渴望对API进行控制，而忽略了客户对于良好的持续性的需求。</p>
<p>查看了 PPT，对于API的版本控制，常见的有如下实现方式(<br>在stackoverflow上看到一个相关问答，其中详细讨论了下述方法优劣<a href="http://stackoverflow.com/questions/389169/best-practices-for-api-versioning/" target="_blank" rel="external">best-practices-for-api-versioning</a><br>):</p>
<ul>
<li>URL里带版本号<br><a href="http://www.host.com/v1/users" target="_blank" rel="external">http://www.host.com/v1/users</a></li>
<li>资源名称里带版本号<br>• <a href="http://example.com/users.v1" target="_blank" rel="external">http://example.com/users.v1</a></li>
<li>查询参数里带版本号<br>• <a href="http://example.com/users?api=v1" target="_blank" rel="external">http://example.com/users?api=v1</a></li>
<li>在HTTP头中制定版本信息<br>• Content-Type: application/vnd.myname.v1+json</li>
</ul>
<p>2、</p>
<blockquote>
<p>Hypertext as the Engine of Application State<br><a href="http://stackoverflow.com/questions/717851/can-someone-explain-hypertext-as-engine-of-application-state-in-simple-terms" target="_blank" rel="external">http://stackoverflow.com/questions/717851/can-someone-explain-hypertext-as-engine-of-application-state-in-simple-terms</a></p>
</blockquote>
<p>也就是说在web的世界里，事物的状态变化是通过link来实现的，你浏览网页，看到了一些内容，点击了其中一些链接跳转到其他的页面上，获取更多的内容<br> Darrel Miller在stackoverflow上的回答</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When attempting to explain hypermedia, I like to use the example of navigating in a car via signposts versus a map. I realize it doesn&#39;t directly answer you question but it may help.&#10;When driving a car and you reach a particular intersection you are provided signposts to indicate where you can go from that point. Similarly, hypermedia provides you with a set of options based on your current state.&#10;A traditional RPC based API is more like a map. With a map you tend to plan your route out based on a static set of road data. One problem with maps is that they can become out of date and they provide no information about traffic or other dynamic factors.&#10;The advantage of signposts is that they can be changed on the fly to detour traffic due to construction or to control traffic flow.&#10;I&#39;m not suggesting that signposts are always a better option than a map. Obviously there are pros and cons but it is valuable to be aware of both options. It is the same with hypermedia. It is a valuable alternative to the traditional RPC interface.</span><br></pre></td></tr></table></figure>
<p>作者强调Rest是一个可Evolvability演化的架构方式，他说不应该对API打上版本号标签，紧接着他抛出REST API版本控制的最佳实践也应该是怎么样的问题？<br>他把RESTAPI比喻成机器与机器交互的website，接着反问谁在网站的地址上看到过版本号这些玩意儿(对于网站而言，向后的兼容性简直是生命线，如果baidu哪天域名换成bidu呢 google换成bidu呢)，紧接着又引用了Paul在“ALWAYS SHIP TRUNK”PPT中的结论，web应用程序都没能很好的解决版本控制的问题，你自己怎么可能搞的定这难题。 接着便引出了Paul在ppt中的观点，如果要给web应用程序设计一个revision control system  版本控制系统，应该是什么样的呢？<br>随即引出了根据feature flag和具体情况激活不同的功能，给出了一种全局配置文件的例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (frags(&#8220;saml_auth&#8221;)) &#123;&#10;  credentials = saml.authenticate(user);&#10;&#125;&#10;else &#123;&#10;  credentials = httpAuth.check(user);&#10;&#125;&#10;&#8226; testable for conditional content (i.e., everything) &#8226; readable via all development interfaces&#10;&#8226; writable with ops authority</span><br></pre></td></tr></table></figure>
<p>后面就是广告时间了，展示了一下他的产品FRAGS的情况，去twitter上搜了一下，说这个产品的点子来源于Paul Hammond<br><a href="http://www.paulhammond.org/2010/06/trunk/" target="_blank" rel="external"> using version control to manage web services.</a>，在这个长达96页的PPT里Paul介绍到：<br>要实现软件的 revision control，既有的分支、分布式分支的方法实现起来问题多多。接着指出现有的revision control的方案是面向可安装的软件这一种软件类型所设计的，他提出软件可以分为三种(要安装的软件、开源的要安装的软件、web应用程序或软件即服务)，考虑到我们不是所有服务器上的管理员，无法保证在公开测试、beta环境、QA环境和AB测试环境下同时发布更新，那么要怎么解决呢？(第39页开始)提出三种思路</p>
<ul>
<li>第一种：基础架构和功能代码启动的分离，二者都可以单独部署，不会影响</li>
<li><p>第二种：同时运行多个版本的代码，来回切换，不论是后台还是UI(这里就需要一个revision control系统来解决代码运行时的动态切换并行存在的多个版本的代码)</p>
</li>
<li><p>传统的分支本身不能帮你解决运行时不同版本间的切换；</p>
</li>
<li>传统的分支不能帮你解决一次性多个版本的依赖关系变化的管理<br>到底怎么样才能解决不同版本切换时的revision control呢？考虑在应用程序内部，也就是代码层面控制不同的版本，换句话说，就是要在代码里利用分支来实现不同版本的控制。<br>紧接着从550-72利用大量的代码演示了如何利用配置文件来设置标记，实现不同功能(功能的切换、功能的启动与否、不同环境下的配置、不同比例的用户使用那些功能、生产环境下的功能测试等)的切换，74页总结了三类feature flag 功能标记</li>
<li>1、Development on user facing features UI界面的</li>
<li>2、Development on infrastructure 后台功能的</li>
<li>3、 Kill-switches</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># killswitch&#10;if ($cfg[&#39;disable_login&#39;]) &#123;&#10;  error(&#39;Sorry, login is unavailable&#39;);&#10;  exit;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>通常而言，需要将三者混合使用，如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># for development&#10;$cfg[&#39;disable_search_tests_all&#39;] = false;&#10;$cfg[&#39;disable_search_ui_beta_test&#39;] = false;&#10;$cfg[&#39;disable_search_darklaunch&#39;] = false;&#10;# for post launch&#10;$cfg[&#39;disable_search&#39;] = false;</span><br></pre></td></tr></table></figure>
<p>作者对于使用分支和feature flag的结论</p>

* 1、前期使用分支来开发。Use branches for early development
* 2、分支要合并到trunk下。Branches merged into trunk
* 3、功能差不多了要上线时使用flag。Use flags for rollout of almost-finished code
   
<p>为了进一步了解feature flag究竟为何物，google一把，定位了几个不错的资源<br>1、<a href="http://stackoverflow.com/questions/7707383/what-is-a-feature-flag" target="_blank" rel="external">stackoverflow上关于feature-flag的讨论</a><br>2、<a href="https://github.com/wangcheng714/feature-flag" target="_blank" rel="external">看起来是百度前端团队某大神整理的feature-flag的材料</a><br>3、<a href="http://technologyconversations.com/2014/08/26/feature-toggles-feature-switches-or-feature-flags-vs-feature-branches/" target="_blank" rel="external">概念的对比和介绍Feature Toggles (Feature Switches or Feature Flags) vs Feature Branches</a><br>4、<a href="http://code.flickr.com/blog/2009/12/02/flipping-out/）
5、[](http://techblog.outbrain.com/tag/feature-flags/" target="_blank" rel="external"></a><br>6、<a href="https://github.com/toutantic/featureflags" target="_blank" rel="external">java代码示例</a><br>7、<a href="http://martinfowler.com/bliki/FeatureToggle.html" target="_blank" rel="external">仍然是matrin大神的博文</a></p>
<p>infoQ上另外一篇文章<a href="http://www.infoq.com/news/2013/12/api-versioning/" target="_blank" rel="external">不同api版本控制策略的成本分析</a>则指出<br>对于如下三种策略：</p>
<ul>
<li>1、只有一个版本，所有消费端使用同一个版本，当API发生变更，消费端也要跟着变。<img src="first-type-version.png" alt=""></li>
<li>2、每个服务的版本都可以在生产环境中使用，客户端按需来就行<img src="second-type-version.png" alt=""></li>
<li>3、有多个版本存在，所有消费端都使用最新的一个版本，版本是向后兼容的<img src="third-type-version.png" alt=""></li>
</ul>
<p><img src="../../../../images/version-type-cost.png" alt="成本分析图">显示向后兼容的版本策略最划算</p>
<p>综上所述：<br>feature flag指的是将功能发布与代码部署分离feature release and code deployment,对于rest API 或者HTTP API 而言，完全没搞懂ROY大神推荐的是那种套路，是说并存多个向后兼容的版本，以feature flag的形式来配置，客户端只访问最新的版本？对于URL和http header 大神似乎不推荐使用任意带版本号的方法。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/日记/">日记</a>►<a class="article-category-link" href="/categories/日记/HTTP-API/">HTTP API</a>►<a class="article-category-link" href="/categories/日记/HTTP-API/REST/">REST</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/HTTP-API/">HTTP API</a><a href="/tags/REST/">REST</a><a href="/tags/日记/">日记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/日记/HTTP-API/" title="HTTP API">HTTP API<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/数据仓库/KAFKA/" title="KAFKA">KAFKA<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/数据仓库/KAFKA/PostgreSQL/" title="PostgreSQL">PostgreSQL<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/HTTP-API/REST/" title="REST">REST<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/REST/" title="REST">REST<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/rhadoop/docker/" title="docker">docker<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/rhadoop/" title="rhadoop">rhadoop<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/互联网医疗/" title="互联网医疗">互联网医疗<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/架构/微服务/" title="微服务">微服务<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/数据仓库/" title="数据仓库">数据仓库<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日志/" title="日志">日志<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/" title="日记">日记<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/日记/架构/" title="架构">架构<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/生活日志/" title="生活日志">生活日志<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/碎碎念/碎碎念/" title="碎碎念">碎碎念<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/碎碎念/" title="碎碎念">碎碎念<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/日志/第一天/" title="第一天">第一天<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/日记/" title="日记">日记<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/架构/" title="架构">架构<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/微服务/" title="微服务">微服务<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/REST/" title="REST">REST<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/碎碎念/" title="碎碎念">碎碎念<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/HTTP-API/" title="HTTP API">HTTP API<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/数据仓库/" title="数据仓库">数据仓库<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/KAFKA/" title="KAFKA">KAFKA<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/碎碎念/" title="碎碎念">碎碎念<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/PostgreSQL/" title="PostgreSQL">PostgreSQL<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/rhadoop/" title="rhadoop">rhadoop<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/模板/" title="模板">模板<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/互联网医疗/" title="互联网医疗">互联网医疗<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/PGHD/" title="PGHD">PGHD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Github-pages/" title="Github pages">Github pages<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/博客/" title="博客">博客<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Oracle/" title="Oracle">Oracle<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Ubuntu/" title="Ubuntu">Ubuntu<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://www.sciencenet.cn/" target="_blank" title="科学网">科学网</a></li>
      <li><a href="http://motorcycleguy.blogspot.com" target="_blank" title="zippera">Keith Boone's Blog</a></li>
      <li><a href="http://www.healthintersections.com.au/" target="_blank" title="Grahame Grieve">Grahame Grieve's Blog</a></li>
      <li><a href="http://mooc.guokr.com/" target="_blank" title="MOOC学院">MOOC学院</a></li>
      <li><a href="https://trello.com/" target="_blank" title="Trello">Trello工具</a></li>


        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>


  

<div class="doubanshow">
<p class="asidetitle">豆瓣秀</p>
<div>
<script type="text/javascript" src="http://www.douban.com/service/badge/48701103/?show=collection&amp;n=12&amp;columns=3&amp;hidelogo=yes&amp;hideself=yes&amp;cat=book|movie" ></script>
</div>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello,I&#39;m wanghaisheng. For now I&#39;m a engineer in ShangHai. <br/>
			曾几何时，幻想着自己能文思如尿奔，写一些生活的感悟，记录一些成长的足迹，辗转从qq空间到chinaunix再到科学网，种种不适，最终在这里落脚。 这里是海生(edwin)的小窝，记录着海生成长过程中的酸甜苦辣。虽努力地想让大家看到、了解、认识真实的自己，海生却不如自己所想的那般勇敢和自信，这其中或多或少是由于天生的那点自尊、自恋和自卑在作祟。文字总是唯美的，我可爱的朋友们，希望你们能够从这些拙劣的话语中找到一丝丝温暖，感受到一丝丝温馨.如果看了我的碎碎念之后,你有要说话的冲动，请不要过分珍惜你的键盘或者是我的空间 －－ 因为，你是我的朋友。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/edwinuestc" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/wanghaisheng" target="_blank" class="icon-github" title="github"></a>
		
		
		
		<a href="https://twitter.com/edwin_uestc" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		
		
		<a href="https://www.douban.com/people/48701103" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		
		<a href="https://plus.google.com/111190881341800840000?rel=author" target="_blank" class="icon-google_plus" title="Google+"></a>
		
		
		<a href="mailto:edwin_uestc@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="Edwin">Edwin</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
